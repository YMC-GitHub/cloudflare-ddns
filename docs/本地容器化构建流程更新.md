我来在现有 Dockerfile 的基础上添加本地开发阶段，保持其他阶段不变：

```dockerfile
# =============================================
# 多阶段构建：构建 + 发布到 GitHub Container Registry
# =============================================

# 基础构建参数
ARG USE_CHINA_MIRROR=false
ARG ALPINE_MIRROR=mirrors.aliyun.com
ARG RUST_MIRROR=tuna

# =============================================
# 阶段1: 本地开发环境
# =============================================
FROM rust:1.90-alpine3.20 AS development

# 继承构建参数
ARG USE_CHINA_MIRROR
ARG ALPINE_MIRROR
ARG RUST_MIRROR

# 条件性配置镜像源
RUN if [ "$USE_CHINA_MIRROR" = "true" ]; then \
        echo "🔧 Using China mirror: $ALPINE_MIRROR" && \
        sed -i "s|dl-cdn.alpinelinux.org|$ALPINE_MIRROR|g" /etc/apk/repositories; \
    else \
        echo "🌍 Using default Alpine sources"; \
    fi

# 安装开发工具和依赖
RUN apk update && apk add --no-cache \
    git \
    gcc \
    musl-dev \
    openssl-dev \
    build-base \
    pkgconfig \
    openssl-libs-static \
    bash \
    curl \
    vim \
    htop \
    file

WORKDIR /app

# 复制项目文件
COPY Cargo.toml ./

# 条件性配置 Cargo 国内源
RUN if [ "$USE_CHINA_MIRROR" = "true" ]; then \
        echo "🔧 Configuring Cargo China mirror: $RUST_MIRROR" && \
        mkdir -p /usr/local/cargo/ && \
        case "$RUST_MIRROR" in \
            "tuna") \
                cat > /usr/local/cargo/config << 'EOF' \
[source.crates-io]
replace-with = 'tuna'

[source.tuna]
registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"

[net]
git-fetch-with-cli = true
EOF
                ;; \
            "ustc") \
                cat > /usr/local/cargo/config << 'EOF' \
[source.crates-io]
replace-with = 'ustc'

[source.ustc]
registry = "https://mirrors.ustc.edu.cn/crates.io-index/"

[net]
git-fetch-with-cli = true
EOF
                ;; \
        esac && \
        echo "✅ Cargo mirror configured: $RUST_MIRROR"; \
    else \
        echo "🌍 Using default Cargo sources"; \
        # 设置 git-fetch-with-cli 以提高稳定性 \
        mkdir -p /usr/local/cargo/ && \
        cat > /usr/local/cargo/config << 'EOF' \
[net]
git-fetch-with-cli = true
EOF
    fi

# 安装开发工具
RUN cargo install cargo-watch cargo-edit

# 预下载依赖
RUN cargo fetch

# 复制源代码
COPY src/ src/

# 开发环境配置
ENV RUST_LOG=debug
ENV RUST_BACKTRACE=1

# 开发环境默认命令
CMD ["cargo", "watch", "-x", "run", "-x", "test"]

# =============================================
# 阶段2: 构建阶段（保持原有不变）
# =============================================
FROM rust:1.90-alpine3.20 AS builder

# 继承构建参数
ARG USE_CHINA_MIRROR
ARG ALPINE_MIRROR
ARG RUST_MIRROR

# 条件性配置镜像源
RUN if [ "$USE_CHINA_MIRROR" = "true" ]; then \
        echo "🔧 Using China mirror: $ALPINE_MIRROR" && \
        sed -i "s|dl-cdn.alpinelinux.org|$ALPINE_MIRROR|g" /etc/apk/repositories; \
    else \
        echo "🌍 Using default Alpine sources"; \
    fi

# 安装构建依赖
RUN apk update && apk add --no-cache \
    git \
    gcc \
    musl-dev \
    openssl-dev \
    build-base \
    pkgconfig \
    openssl-libs-static \
    upx \
    file

WORKDIR /app

# 只复制必要的配置
COPY Cargo.toml ./

# 条件性配置 Cargo 国内源
RUN if [ "$USE_CHINA_MIRROR" = "true" ]; then \
        echo "🔧 Configuring Cargo China mirror: $RUST_MIRROR" && \
        mkdir -p /usr/local/cargo/ && \
        case "$RUST_MIRROR" in \
            "tuna") \
                cat > /usr/local/cargo/config << 'EOF' \
[source.crates-io]
replace-with = 'tuna'

[source.tuna]
registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"

[net]
git-fetch-with-cli = true
EOF
                ;; \
            "ustc") \
                cat > /usr/local/cargo/config << 'EOF' \
[source.crates-io]
replace-with = 'ustc'

[source.ustc]
registry = "https://mirrors.ustc.edu.cn/crates.io-index/"

[net]
git-fetch-with-cli = true
EOF
                ;; \
        esac && \
        echo "✅ Cargo mirror configured: $RUST_MIRROR"; \
    else \
        echo "🌍 Using default Cargo sources"; \
        # 设置 git-fetch-with-cli 以提高稳定性 \
        mkdir -p /usr/local/cargo/ && \
        cat > /usr/local/cargo/config << 'EOF' \
[net]
git-fetch-with-cli = true
EOF
    fi

# 创建假的 src 目录来缓存依赖
RUN mkdir -p src && \
    echo "fn main() {}" > src/main.rs && \
    echo "// dummy lib" > src/lib.rs

# 构建依赖（缓存层）
RUN cargo fetch

RUN cargo build --release --target x86_64-unknown-linux-musl

# 现在复制真正的源代码
COPY src/ src/

# 真实构建
RUN rm -f target/x86_64-unknown-linux-musl/release/deps/cloudflare_ddns-* && \
    cargo build --release --target x86_64-unknown-linux-musl

# 优化二进制（移除调试符号并压缩）
RUN strip target/x86_64-unknown-linux-musl/release/cloudflare-ddns && \
    upx --best --lzma target/x86_64-unknown-linux-musl/release/cloudflare-ddns

# 验证构建结果
RUN echo "=== Build Verification ===" && \
    ls -lh target/x86_64-unknown-linux-musl/release/cloudflare-ddns && \
    file target/x86_64-unknown-linux-musl/release/cloudflare-ddns && \
    echo "=== Static Link Check ===" && \
    ldd target/x86_64-unknown-linux-musl/release/cloudflare-ddns 2>&1 | head -3

# =============================================
# 阶段3: 证书准备阶段（保持原有不变）
# =============================================
FROM alpine:3.20 AS certs

# 继承构建参数
ARG USE_CHINA_MIRROR
ARG ALPINE_MIRROR

# 条件性配置镜像源
RUN if [ "$USE_CHINA_MIRROR" = "true" ]; then \
        echo "🔧 Using China mirror in certs stage: $ALPINE_MIRROR" && \
        sed -i "s|dl-cdn.alpinelinux.org|$ALPINE_MIRROR|g" /etc/apk/repositories; \
    fi

# 安装证书和时区数据
RUN apk update && apk add --no-cache ca-certificates tzdata && \
    update-ca-certificates

# =============================================
# 阶段4: 最终运行镜像（scratch）（保持原有不变）
# =============================================
FROM scratch AS runtime

# 复制 SSL 证书（必须，因为你的应用需要 HTTPS）
COPY --from=certs /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# 时区信息
COPY --from=certs /usr/share/zoneinfo /usr/share/zoneinfo
ENV TZ=Asia/Shanghai

# 复制二进制文件
COPY --from=builder /app/target/x86_64-unknown-linux-musl/release/cloudflare-ddns /app/cloudflare-ddns

# 设置入口点
ENTRYPOINT ["/app/cloudflare-ddns"]
```

## 🚀 本地开发使用方法

### 1. 构建开发环境
```bash
# 构建开发镜像
docker build --target development -t cloudflare-ddns:dev .

# docker build --target development --build-arg USE_CHINA_MIRROR=true -t cloudflare-ddns:dev .

# 使用国内镜像构建开发环境
docker build \
  --target development \
  --build-arg USE_CHINA_MIRROR=true \
  --build-arg ALPINE_MIRROR=mirrors.aliyun.com \
  --build-arg RUST_MIRROR=ustc \
  -t cloudflare-ddns:dev .
```

### 2. 运行开发容器
```bash
# 运行开发容器（自动监视文件变化）
docker run -it --rm \
  -v $(pwd):/app \
  -v cloudflare-ddns-cargo-cache:/usr/local/cargo/registry \
  -v cloudflare-ddns-target-cache:/app/target \
  -p 8080:8080 \
  cloudflare-ddns:dev

# 或者进入开发容器手动操作
# uc2
docker run -it --rm -v $(pwd):/app -v cloudflare-ddns-cargo-cache:/usr/local/cargo/registry cloudflare-ddns:dev sh

# uc3
docker run -it --rm -v $(pwd)/src:/app/src -v cloudflare-ddns-cargo-cache:/usr/local/cargo/registry cloudflare-ddns:dev sh

# 运行开发版本:
# cargo run -- --show-platform
# cargo run -- --version
# cargo run -- --help

# cargo run -- --config .env.example

# export ENV_FILE=/app/.env.example;echo $ENV_FILE;cargo run 
# export ENV_FILE=.env.example;echo $ENV_FILE;cargo run 
# export ENV_FILE=;echo $ENV_FILE;cargo run  # to fix
# unset ENV_FILE;env;cargo run 

# cargo run -- --show-config
# cargo run -- --config .env.example --show-config
# export ENV_FILE=/app/.env.example;echo $ENV_FILE;cargo run -- --show-config
# export ENV_FILE=.env.example;echo $ENV_FILE;cargo run -- --show-config
# export ENV_FILE=;echo $ENV_FILE;cargo run  -- --show-config
# unset ENV_FILE;env;cargo run  -- --show-config



# test:
# cargo test

# 构建发布版本:
# cargo build --release
# cargo build --release --target x86_64-unknown-linux-musl

# 运行发布版:
# ./target/x86_64-unknown-linux-musl/release/cloudflare-ddns --version
# ./target/x86_64-unknown-linux-musl/release/cloudflare-ddns --help
# ./target/x86_64-unknown-linux-musl/release/cloudflare-ddns --show-platform
# ./target/x86_64-unknown-linux-musl/release/cloudflare-ddns --config .env.example

```

### 3. 使用 Docker Compose（推荐）
创建 `docker-compose.dev.yml`：
```yaml
version: '3.8'

services:
  cloudflare-ddns-dev:
    build:
      context: .
      target: development
      args:
        USE_CHINA_MIRROR: false
        ALPINE_MIRROR: mirrors.aliyun.com
        RUST_MIRROR: tuna
    container_name: cloudflare-ddns-dev
    volumes:
      - .:/app
      - cargo-cache:/usr/local/cargo/registry
      - target-cache:/app/target
    environment:
      - RUST_LOG=debug
      - RUST_BACKTRACE=1
    working_dir: /app
    stdin_open: true
    tty: true

volumes:
  cargo-cache:
  target-cache:
```

使用 Compose：
```bash
# 启动开发环境
docker-compose -f docker-compose.dev.yml up

# 在后台运行
docker-compose -f docker-compose.dev.yml up -d

# 进入容器
docker-compose -f docker-compose.dev.yml exec cloudflare-ddns-dev sh

# 查看日志
docker-compose -f docker-compose.dev.yml logs -f
```

### 4. 开发环境中的常用命令
```bash
# 在运行中的开发容器中执行
docker exec -it cloudflare-ddns-dev cargo test
docker exec -it cloudflare-ddns-dev cargo clippy
docker exec -it cloudflare-ddns-dev cargo fmt
docker exec -it cloudflare-ddns-dev cargo add new-dependency
```

### 5. 生产构建（保持不变）
```bash
# 构建生产镜像
docker build --target runtime -t cloudflare-ddns:scratch .

# 使用国内镜像构建生产版本
docker build \
  --target runtime \
  --build-arg USE_CHINA_MIRROR=true \
  -t cloudflare-ddns:scratch .
```

## 🎯 开发阶段特性

- **热重载**: 使用 `cargo watch` 自动重新编译
- **完整工具链**: 包含 vim, curl, git 等开发工具
- **依赖缓存**: 使用 volume 缓存 cargo registry 和 target
- **调试支持**: 设置 `RUST_LOG=debug` 和 `RUST_BACKTRACE=1`
- **代码同步**: 实时同步宿主机代码到容器

这样就在不改变原有构建阶段的基础上，添加了完整的本地开发环境！
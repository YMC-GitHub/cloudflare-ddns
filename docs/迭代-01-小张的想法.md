## 小张的想法
小张想使用rust编写一个可执行文件。有这些要求：
1.服务部署在容器中。
2.容器使用轻量化镜像。
3.使用环境变量来自可选的env文件。
4.为环境变量设置默认值。
5.支持多个域名进行ddns,使用cloudflare-ddns。


我来帮你创建一个使用 Rust 编写的 DDNS 可执行文件，满足你的所有要求。

## 1. 项目结构

首先创建项目：
```bash
cargo new cloudflare-ddns
cd cloudflare-ddns
```

## 2. Cargo.toml

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
```

## 3. 主程序 src/main.rs

```rust
use anyhow::Result;
use config::{Config, Environment, File};
use log::{info, error};
use serde::Deserialize;
use std::collections::HashMap;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Debug, Deserialize, Clone)]
struct DomainConfig {
    zone_id: String,
    record_name: String,
    api_token: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
}

#[derive(Debug, Deserialize)]
struct AppConfig {
    #[serde(default = "default_interval")]
    update_interval: u64,
    domains: HashMap<String, DomainConfig>,
}

fn default_interval() -> u64 {
    300 // 5 minutes
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let mut cfg = Config::builder();

        // 设置默认值
        cfg = cfg.set_default("update_interval", 300)?;

        // 从可选的 env 文件加载
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        }

        // 从环境变量加载，支持嵌套结构
        cfg = cfg.add_source(
            Environment::with_prefix("DDNS")
                .prefix_separator("_")
                .separator("__")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let app_config: AppConfig = config.try_deserialize()?;
        
        Ok(app_config)
    }
}

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }

    async fn get_current_ip(&self) -> Result<String> {
        let response = self.client
            .get("https://api.ipify.org")
            .send()
            .await?
            .text()
            .await?;
        Ok(response)
    }

    async fn update_dns_record(
        &self,
        domain_config: &DomainConfig,
        ip: &str,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            domain_config.zone_id
        );

        // 首先查找现有的记录
        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", domain_config.api_token))
            .query(&[("name", &domain_config.record_name), ("type", &"A".to_string())])
            .send()
            .await?;

        let records: serde_json::Value = response.json().await?;
        
        if let Some(records_array) = records["result"].as_array() {
            if let Some(record) = records_array.first() {
                let record_id = record["id"].as_str().unwrap();
                
                // 更新现有记录
                let update_url = format!("{}/{}", url, record_id);
                let update_data = serde_json::json!({
                    "type": "A",
                    "name": domain_config.record_name,
                    "content": ip,
                    "ttl": domain_config.ttl,
                    "proxied": domain_config.proxy
                });

                let response = self.client
                    .put(&update_url)
                    .header("Authorization", format!("Bearer {}", domain_config.api_token))
                    .header("Content-Type", "application/json")
                    .json(&update_data)
                    .send()
                    .await?;

                if response.status().is_success() {
                    info!("Successfully updated DNS record for {}", domain_config.record_name);
                } else {
                    let error_text = response.text().await?;
                    error!("Failed to update DNS record for {}: {}", domain_config.record_name, error_text);
                    return Err(anyhow::anyhow!("Cloudflare API error: {}", error_text));
                }
            } else {
                // 创建新记录
                let create_data = serde_json::json!({
                    "type": "A",
                    "name": domain_config.record_name,
                    "content": ip,
                    "ttl": domain_config.ttl,
                    "proxied": domain_config.proxy
                });

                let response = self.client
                    .post(&url)
                    .header("Authorization", format!("Bearer {}", domain_config.api_token))
                    .header("Content-Type", "application/json")
                    .json(&create_data)
                    .send()
                    .await?;

                if response.status().is_success() {
                    info!("Successfully created DNS record for {}", domain_config.record_name);
                } else {
                    let error_text = response.text().await?;
                    error!("Failed to create DNS record for {}: {}", domain_config.record_name, error_text);
                    return Err(anyhow::anyhow!("Cloudflare API error: {}", error_text));
                }
            }
        }

        Ok(())
    }
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let current_ip = client.get_current_ip().await?;
    info!("Current public IP: {}", current_ip);

    for (domain_name, domain_config) in &config.domains {
        info!("Updating DNS record for domain: {}", domain_name);
        if let Err(e) = client.update_dns_record(domain_config, &current_ip).await {
            error!("Error updating domain {}: {}", domain_name, e);
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let config = AppConfig::new()?;
    info!("Loaded configuration: {:?}", config);
    
    let client = CloudflareClient::new();
    
    loop {
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("DDNS update error: {}", e);
        }
        
        sleep(Duration::from_secs(config.update_interval)).await;
    }
}
```

## 4. Dockerfile

```dockerfile
# 构建阶段
FROM rust:1.70-slim as builder

WORKDIR /app
COPY . .
RUN cargo build --release

# 运行阶段
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# 创建非root用户
RUN useradd -m -u 1000 appuser
USER appuser

WORKDIR /app
COPY --from=builder /app/target/release/cloudflare-ddns /app/

# 创建可选的env文件目录
RUN mkdir -p /app/config

CMD ["/app/cloudflare-ddns"]
```

## 5. 环境变量配置文件示例

创建 `config.env`：
```bash
# 更新间隔（秒）
DDNS_UPDATE_INTERVAL=300

# 域名配置
# 域名1
DDNS_DOMAINS__EXAMPLE_COM__ZONE_ID=your_zone_id_1
DDNS_DOMAINS__EXAMPLE_COM__RECORD_NAME=example.com
DDNS_DOMAINS__EXAMPLE_COM__API_TOKEN=your_api_token_1
DDNS_DOMAINS__EXAMPLE_COM__PROXY=true
DDNS_DOMAINS__EXAMPLE_COM__TTL=120

# 域名2
DDNS_DOMAINS__SUBDOMAIN_EXAMPLE_COM__ZONE_ID=your_zone_id_2
DDNS_DOMAINS__SUBDOMAIN_EXAMPLE_COM__RECORD_NAME=subdomain.example.com
DDNS_DOMAINS__SUBDOMAIN_EXAMPLE_COM__API_TOKEN=your_api_token_2
DDNS_DOMAINS__SUBDOMAIN_EXAMPLE_COM__PROXY=false
DDNS_DOMAINS__SUBDOMAIN_EXAMPLE_COM__TTL=300
```

## 6. 构建和运行

### 构建 Docker 镜像：
```bash
docker build -t cloudflare-ddns .
```

### 运行容器：

**方式1：使用环境变量文件**
```bash
docker run -d \
  --name ddns \
  --env-file config.env \
  cloudflare-ddns
```

**方式2：直接设置环境变量**
```bash
docker run -d \
  --name ddns \
  -e DDNS_UPDATE_INTERVAL=300 \
  -e DDNS_DOMAINS__EXAMPLE_COM__ZONE_ID=your_zone_id \
  -e DDNS_DOMAINS__EXAMPLE_COM__RECORD_NAME=example.com \
  -e DDNS_DOMAINS__EXAMPLE_COM__API_TOKEN=your_api_token \
  cloudflare-ddns
```

**方式3：使用外部env文件**
```bash
docker run -d \
  --name ddns \
  -v $(pwd)/config:/app/config \
  -e ENV_FILE=/app/config/config.env \
  cloudflare-ddns
```

## 7. 特性说明

这个实现满足你的所有要求：

1. **容器化部署**：使用多阶段构建的 Dockerfile
2. **轻量化镜像**：基于 debian-slim，最终镜像很小
3. **可选环境变量文件**：通过 `ENV_FILE` 环境变量指定
4. **默认值设置**：所有配置项都有合理的默认值
5. **多域名支持**：支持配置多个 Cloudflare 域名
6. **错误处理**：完善的错误处理和日志记录
7. **周期性更新**：可配置的更新间隔

## 8. 配置说明

- `update_interval`: 更新间隔（秒），默认300秒
- 每个域名配置：
  - `zone_id`: Cloudflare 区域 ID
  - `record_name`: 域名记录名称
  - `api_token`: Cloudflare API token
  - `proxy`: 是否开启 Cloudflare 代理（默认false）
  - `ttl`: DNS记录TTL（默认120）

这个解决方案提供了灵活的环境变量配置方式，支持从文件或直接设置环境变量，并且镜像体积小，适合容器化部署。
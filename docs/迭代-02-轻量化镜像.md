好的！我来更新项目以使用 `rust:1.90-alpine3.20` 镜像，这样可以获得更小的镜像体积。

## 1. 更新 Cargo.toml

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
```

## 2. 更新 Dockerfile

```dockerfile
# 构建阶段
FROM rust:1.90-alpine3.20 as builder

# 安装构建依赖
RUN apk add --no-cache musl-dev openssl-dev openssl-libs-static pkgconfig

WORKDIR /app
COPY . .
RUN cargo build --release

# 运行阶段
FROM alpine:3.20

# 安装运行时依赖
RUN apk add --no-cache ca-certificates libgcc

# 创建非root用户
RUN adduser -D -u 1000 appuser
USER appuser

WORKDIR /app
COPY --from=builder /app/target/release/cloudflare-ddns /app/

# 创建可选的env文件目录
RUN mkdir -p /app/config

CMD ["/app/cloudflare-ddns"]
```

## 3. 主程序 src/main.rs

```rust
use anyhow::Result;
use config::{Config, Environment, File};
use log::{info, error};
use serde::Deserialize;
use std::collections::HashMap;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Debug, Deserialize, Clone)]
struct DomainConfig {
    zone_id: String,
    record_name: String,
    api_token: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
}

#[derive(Debug, Deserialize)]
struct AppConfig {
    #[serde(default = "default_interval")]
    update_interval: u64,
    domains: HashMap<String, DomainConfig>,
}

fn default_interval() -> u64 {
    300 // 5 minutes
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let mut cfg = Config::builder();

        // 设置默认值
        cfg = cfg.set_default("update_interval", 300)?;

        // 从可选的 env 文件加载
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        }

        // 从环境变量加载，支持嵌套结构
        cfg = cfg.add_source(
            Environment::with_prefix("DDNS")
                .prefix_separator("_")
                .separator("__")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let app_config: AppConfig = config.try_deserialize()?;
        
        Ok(app_config)
    }
}

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }

    async fn get_current_ip(&self) -> Result<String> {
        let response = self.client
            .get("https://api.ipify.org")
            .send()
            .await?
            .text()
            .await?;
        Ok(response)
    }

    async fn get_existing_record_id(
        &self,
        domain_config: &DomainConfig,
    ) -> Result<Option<String>> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            domain_config.zone_id
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", domain_config.api_token))
            .query(&[("name", &domain_config.record_name), ("type", &"A".to_string())])
            .send()
            .await?;

        let records: serde_json::Value = response.json().await?;
        
        if let Some(records_array) = records["result"].as_array() {
            if let Some(record) = records_array.first() {
                if let Some(record_id) = record["id"].as_str() {
                    return Ok(Some(record_id.to_string()));
                }
            }
        }

        Ok(None)
    }

    async fn update_dns_record(
        &self,
        domain_config: &DomainConfig,
        ip: &str,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            domain_config.zone_id
        );

        if let Some(record_id) = self.get_existing_record_id(domain_config).await? {
            // 更新现有记录
            let update_url = format!("{}/{}", url, record_id);
            let update_data = serde_json::json!({
                "type": "A",
                "name": domain_config.record_name,
                "content": ip,
                "ttl": domain_config.ttl,
                "proxied": domain_config.proxy
            });

            let response = self.client
                .put(&update_url)
                .header("Authorization", format!("Bearer {}", domain_config.api_token))
                .header("Content-Type", "application/json")
                .json(&update_data)
                .send()
                .await?;

            if response.status().is_success() {
                info!("Successfully updated DNS record for {}", domain_config.record_name);
            } else {
                let error_text = response.text().await?;
                error!("Failed to update DNS record for {}: {}", domain_config.record_name, error_text);
                return Err(anyhow::anyhow!("Cloudflare API error: {}", error_text));
            }
        } else {
            // 创建新记录
            let create_data = serde_json::json!({
                "type": "A",
                "name": domain_config.record_name,
                "content": ip,
                "ttl": domain_config.ttl,
                "proxied": domain_config.proxy
            });

            let response = self.client
                .post(&url)
                .header("Authorization", format!("Bearer {}", domain_config.api_token))
                .header("Content-Type", "application/json")
                .json(&create_data)
                .send()
                .await?;

            if response.status().is_success() {
                info!("Successfully created DNS record for {}", domain_config.record_name);
            } else {
                let error_text = response.text().await?;
                error!("Failed to create DNS record for {}: {}", domain_config.record_name, error_text);
                return Err(anyhow::anyhow!("Cloudflare API error: {}", error_text));
            }
        }

        Ok(())
    }
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let current_ip = client.get_current_ip().await?;
    info!("Current public IP: {}", current_ip);

    for (domain_name, domain_config) in &config.domains {
        info!("Updating DNS record for domain: {}", domain_name);
        if let Err(e) = client.update_dns_record(domain_config, &current_ip).await {
            error!("Error updating domain {}: {}", domain_name, e);
        } else {
            info!("Successfully processed domain: {}", domain_name);
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("Failed to load configuration: {}", e);
            std::process::exit(1);
        }
    };
    
    info!("Starting Cloudflare DDNS client");
    info!("Update interval: {} seconds", config.update_interval);
    info!("Monitoring {} domains", config.domains.len());
    
    let client = CloudflareClient::new();
    
    // 立即执行一次更新
    if let Err(e) = run_ddns_update(&client, &config).await {
        error!("Initial DDNS update failed: {}", e);
    }
    
    // 然后按间隔循环执行
    loop {
        sleep(Duration::from_secs(config.update_interval)).await;
        
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("DDNS update error: {}", e);
        }
    }
}
```

## 4. 环境变量配置文件示例

创建 `config.env`：
```bash
# 更新间隔（秒）
DDNS_UPDATE_INTERVAL=300

# 域名配置
# 域名1 - 主域名
DDNS_DOMAINS__EXAMPLE_COM__ZONE_ID=your_zone_id_1
DDNS_DOMAINS__EXAMPLE_COM__RECORD_NAME=example.com
DDNS_DOMAINS__EXAMPLE_COM__API_TOKEN=your_api_token_1
DDNS_DOMAINS__EXAMPLE_COM__PROXY=true
DDNS_DOMAINS__EXAMPLE_COM__TTL=120

# 域名2 - 子域名
DDNS_DOMAINS__WWW_EXAMPLE_COM__ZONE_ID=your_zone_id_1
DDNS_DOMAINS__WWW_EXAMPLE_COM__RECORD_NAME=www.example.com
DDNS_DOMAINS__WWW_EXAMPLE_COM__API_TOKEN=your_api_token_1
DDNS_DOMAINS__WWW_EXAMPLE_COM__PROXY=false
DDNS_DOMAINS__WWW_EXAMPLE_COM__TTL=300

# 域名3 - 另一个域名
DDNS_DOMAINS__ANOTHER_DOMAIN_COM__ZONE_ID=your_zone_id_2
DDNS_DOMAINS__ANOTHER_DOMAIN_COM__RECORD_NAME=another-domain.com
DDNS_DOMAINS__ANOTHER_DOMAIN_COM__API_TOKEN=your_api_token_2
DDNS_DOMAINS__ANOTHER_DOMAIN_COM__PROXY=true
DDNS_DOMAINS__ANOTHER_DOMAIN_COM__TTL=60
```

## 5. 构建和运行

### 构建 Docker 镜像：
```bash
docker build -t cloudflare-ddns .
```

### 运行容器：

**方式1：使用环境变量文件**
```bash
docker run -d \
  --name ddns \
  --env-file config.env \
  cloudflare-ddns
```

**方式2：直接设置环境变量**
```bash
docker run -d \
  --name ddns \
  -e DDNS_UPDATE_INTERVAL=300 \
  -e DDNS_DOMAINS__EXAMPLE_COM__ZONE_ID=your_zone_id \
  -e DDNS_DOMAINS__EXAMPLE_COM__RECORD_NAME=example.com \
  -e DDNS_DOMAINS__EXAMPLE_COM__API_TOKEN=your_api_token \
  cloudflare-ddns
```

**方式3：使用外部env文件**
```bash
docker run -d \
  --name ddns \
  -v $(pwd)/config:/app/config \
  -e ENV_FILE=/app/config/config.env \
  cloudflare-ddns
```

## 6. 改进说明

使用 Alpine 镜像的主要优势：

1. **更小的镜像体积**：Alpine 基础镜像只有约 5MB
2. **更好的安全性**：最小化的基础环境
3. **更快的启动时间**：轻量级运行时

主要改动：
- 使用 `rust:1.90-alpine3.20` 作为构建镜像
- 使用 `alpine:3.20` 作为运行时镜像
- 添加了 Alpine 特定的依赖包
- 改进了错误处理和日志输出
- 优化了 DNS 记录查找逻辑

这个版本保持了所有原有功能，同时显著减小了镜像体积，更适合容器化部署。
根据你提供的环境变量文件格式，我来更新配置解析逻辑。你的格式更简洁，支持多个域名用逗号分隔。

## 1. 更新 Cargo.toml

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
```

## 2. 更新主程序 src/main.rs

```rust
use anyhow::Result;
use config::{Config, Environment, File};
use log::{info, error, warn};
use serde::Deserialize;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Debug, Deserialize)]
struct AppConfig {
    #[serde(default = "default_interval")]
    update_interval: u64,
    
    // Cloudflare API 配置
    cf_api_token: String,
    cf_zone_id: String,
    
    // DNS 记录配置
    dns_record_name: String,
    #[serde(default = "default_record_type")]
    dns_record_type: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
}

fn default_interval() -> u64 {
    300 // 5 minutes
}

fn default_record_type() -> String {
    "A".to_string()
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let mut cfg = Config::builder();

        // 设置默认值
        cfg = cfg.set_default("update_interval", 300)?;
        cfg = cfg.set_default("dns_record_type", "A")?;
        cfg = cfg.set_default("proxy", false)?;
        cfg = cfg.set_default("ttl", 120)?;

        // 从可选的 env 文件加载
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        }

        // 从环境变量加载
        cfg = cfg.add_source(
            Environment::with_prefix("CF")
                .prefix_separator("_")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let app_config: AppConfig = config.try_deserialize()?;
        
        Ok(app_config)
    }

    // 解析多个域名
    fn get_domain_names(&self) -> Vec<String> {
        self.dns_record_name
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect()
    }
}

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }

    async fn get_current_ip(&self, record_type: &str) -> Result<String> {
        let service = match record_type {
            "AAAA" => "https://api6.ipify.org",
            _ => "https://api.ipify.org",
        };

        let response = self.client
            .get(service)
            .send()
            .await?
            .text()
            .await?;
        Ok(response)
    }

    async fn get_existing_record_id(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
    ) -> Result<Option<String>> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .query(&[("name", record_name), ("type", record_type)])
            .send()
            .await?;

        let records: serde_json::Value = response.json().await?;
        
        if records["success"].as_bool() != Some(true) {
            let errors = records["errors"].to_string();
            return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
        }
        
        if let Some(records_array) = records["result"].as_array() {
            if let Some(record) = records_array.first() {
                if let Some(record_id) = record["id"].as_str() {
                    return Ok(Some(record_id.to_string()));
                }
            }
        }

        Ok(None)
    }

    async fn update_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        if let Some(record_id) = self.get_existing_record_id(zone_id, record_name, record_type, api_token).await? {
            // 更新现有记录
            let update_url = format!("{}/{}", url, record_id);
            let update_data = serde_json::json!({
                "type": record_type,
                "name": record_name,
                "content": ip,
                "ttl": ttl,
                "proxied": proxy
            });

            let response = self.client
                .put(&update_url)
                .header("Authorization", format!("Bearer {}", api_token))
                .header("Content-Type", "application/json")
                .json(&update_data)
                .send()
                .await?;

            let result: serde_json::Value = response.json().await?;
            
            if result["success"].as_bool() == Some(true) {
                info!("✅ Successfully updated DNS record: {} -> {}", record_name, ip);
            } else {
                let errors = result["errors"].to_string();
                error!("❌ Failed to update DNS record {}: {}", record_name, errors);
                return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
            }
        } else {
            // 创建新记录
            let create_data = serde_json::json!({
                "type": record_type,
                "name": record_name,
                "content": ip,
                "ttl": ttl,
                "proxied": proxy
            });

            let response = self.client
                .post(&url)
                .header("Authorization", format!("Bearer {}", api_token))
                .header("Content-Type", "application/json")
                .json(&create_data)
                .send()
                .await?;

            let result: serde_json::Value = response.json().await?;
            
            if result["success"].as_bool() == Some(true) {
                info!("✅ Successfully created DNS record: {} -> {}", record_name, ip);
            } else {
                let errors = result["errors"].to_string();
                error!("❌ Failed to create DNS record {}: {}", record_name, errors);
                return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
            }
        }

        Ok(())
    }
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let current_ip = client.get_current_ip(&config.dns_record_type).await?;
    info!("🌐 Current public IP: {}", current_ip);

    let domain_names = config.get_domain_names();
    
    if domain_names.is_empty() {
        warn!("⚠️ No domain names configured");
        return Ok(());
    }

    info!("📝 Processing {} domain(s): {:?}", domain_names.len(), domain_names);

    for domain_name in domain_names {
        info!("🔄 Updating DNS record for: {}", domain_name);
        if let Err(e) = client.update_dns_record(
            &config.cf_zone_id,
            &domain_name,
            &config.dns_record_type,
            &config.cf_api_token,
            &current_ip,
            config.ttl,
            config.proxy,
        ).await {
            error!("❌ Error updating domain {}: {}", domain_name, e);
        } else {
            info!("✅ Successfully processed domain: {}", domain_name);
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("❌ Failed to load configuration: {}", e);
            eprintln!("💡 Please check your environment variables:");
            eprintln!("   - CF_API_TOKEN");
            eprintln!("   - CF_ZONE_ID"); 
            eprintln!("   - DNS_RECORD_NAME");
            eprintln!("   - DNS_RECORD_TYPE (optional, defaults to A)");
            eprintln!("   - PROXY (optional, defaults to false)");
            eprintln!("   - TTL (optional, defaults to 120)");
            std::process::exit(1);
        }
    };
    
    info!("🚀 Starting Cloudflare DDNS client");
    info!("⏰ Update interval: {} seconds", config.update_interval);
    info!("🌍 Zone ID: {}", config.cf_zone_id);
    info!("📋 Record type: {}", config.dns_record_type);
    info("🛡️ Proxy enabled: {}", config.proxy);
    info!("⏱️ TTL: {} seconds", config.ttl);
    
    let domains = config.get_domain_names();
    info!("🎯 Monitoring {} domain(s): {:?}", domains.len(), domains);
    
    let client = CloudflareClient::new();
    
    // 立即执行一次更新
    info!("🔄 Performing initial DDNS update...");
    if let Err(e) = run_ddns_update(&client, &config).await {
        error!("❌ Initial DDNS update failed: {}", e);
    }
    
    info!("🔄 Starting update loop with {} second interval", config.update_interval);
    
    // 然后按间隔循环执行
    loop {
        sleep(Duration::from_secs(config.update_interval)).await;
        
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("❌ DDNS update error: {}", e);
        }
    }
}
```

## 3. 更新 Dockerfile

```dockerfile
# 构建阶段
FROM rust:1.90-alpine3.20 as builder

# 安装构建依赖
RUN apk add --no-cache musl-dev openssl-dev openssl-libs-static pkgconfig

WORKDIR /app
COPY . .
RUN cargo build --release

# 运行阶段
FROM alpine:3.20

# 安装运行时依赖
RUN apk add --no-cache ca-certificates libgcc

# 创建非root用户
RUN adduser -D -u 1000 appuser
USER appuser

WORKDIR /app
COPY --from=builder /app/target/release/cloudflare-ddns /app/

# 创建可选的env文件目录
RUN mkdir -p /app/config

CMD ["/app/cloudflare-ddns"]
```

## 4. 环境变量文件示例

创建 `config.env`：
```bash
# Cloudflare API configuration
# Replace with your API Token
CF_API_TOKEN="J1Hcxx"  
# Replace with your Zone ID
CF_ZONE_ID="af8axx"      
# The name of the record to be updated (supports multiple domains separated by commas)
DNS_RECORD_NAME="me.code.com,hn.code.com"    
# Record type, usually A or AAAA
DNS_RECORD_TYPE="A"             
# Enable Cloudflare proxy (optional, default: false)
PROXY=false
# TTL in seconds (optional, default: 120)
TTL=120
# Update interval in seconds (optional, default: 300)
UPDATE_INTERVAL=300
```

## 5. 构建和运行

### 构建 Docker 镜像：
```bash
docker build -t cloudflare-ddns .
```

### 运行容器：

**方式1：使用环境变量文件**
```bash
docker run -d \
  --name ddns \
  --env-file config.env \
  cloudflare-ddns
```

**方式2：直接设置环境变量**
```bash
docker run -d \
  --name ddns \
  -e CF_API_TOKEN="your_api_token" \
  -e CF_ZONE_ID="your_zone_id" \
  -e DNS_RECORD_NAME="me.code.com,hn.code.com" \
  -e DNS_RECORD_TYPE="A" \
  -e PROXY=false \
  -e TTL=120 \
  -e UPDATE_INTERVAL=300 \
  cloudflare-ddns
```

## 6. 主要改进

1. **兼容你的环境变量格式**：使用 `CF_` 前缀的环境变量
2. **支持多域名**：用逗号分隔多个域名
3. **更好的错误处理**：检查 Cloudflare API 响应中的 success 字段
4. **更清晰的日志**：使用表情符号和结构化输出
5. **IPv6 支持**：根据记录类型自动选择 IPv4/IPv6 查询服务
6. **配置验证**：启动时检查必要的环境变量

现在这个版本完全兼容你提供的环境变量格式，同时支持多个域名的 DDNS 更新。
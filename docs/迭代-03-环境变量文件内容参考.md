æ ¹æ®ä½ æä¾›çš„ç¯å¢ƒå˜é‡æ–‡ä»¶æ ¼å¼ï¼Œæˆ‘æ¥æ›´æ–°é…ç½®è§£æé€»è¾‘ã€‚ä½ çš„æ ¼å¼æ›´ç®€æ´ï¼Œæ”¯æŒå¤šä¸ªåŸŸåç”¨é€—å·åˆ†éš”ã€‚

## 1. æ›´æ–° Cargo.toml

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
```

## 2. æ›´æ–°ä¸»ç¨‹åº src/main.rs

```rust
use anyhow::Result;
use config::{Config, Environment, File};
use log::{info, error, warn};
use serde::Deserialize;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Debug, Deserialize)]
struct AppConfig {
    #[serde(default = "default_interval")]
    update_interval: u64,
    
    // Cloudflare API é…ç½®
    cf_api_token: String,
    cf_zone_id: String,
    
    // DNS è®°å½•é…ç½®
    dns_record_name: String,
    #[serde(default = "default_record_type")]
    dns_record_type: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
}

fn default_interval() -> u64 {
    300 // 5 minutes
}

fn default_record_type() -> String {
    "A".to_string()
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let mut cfg = Config::builder();

        // è®¾ç½®é»˜è®¤å€¼
        cfg = cfg.set_default("update_interval", 300)?;
        cfg = cfg.set_default("dns_record_type", "A")?;
        cfg = cfg.set_default("proxy", false)?;
        cfg = cfg.set_default("ttl", 120)?;

        // ä»å¯é€‰çš„ env æ–‡ä»¶åŠ è½½
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        }

        // ä»ç¯å¢ƒå˜é‡åŠ è½½
        cfg = cfg.add_source(
            Environment::with_prefix("CF")
                .prefix_separator("_")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let app_config: AppConfig = config.try_deserialize()?;
        
        Ok(app_config)
    }

    // è§£æå¤šä¸ªåŸŸå
    fn get_domain_names(&self) -> Vec<String> {
        self.dns_record_name
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect()
    }
}

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }

    async fn get_current_ip(&self, record_type: &str) -> Result<String> {
        let service = match record_type {
            "AAAA" => "https://api6.ipify.org",
            _ => "https://api.ipify.org",
        };

        let response = self.client
            .get(service)
            .send()
            .await?
            .text()
            .await?;
        Ok(response)
    }

    async fn get_existing_record_id(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
    ) -> Result<Option<String>> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .query(&[("name", record_name), ("type", record_type)])
            .send()
            .await?;

        let records: serde_json::Value = response.json().await?;
        
        if records["success"].as_bool() != Some(true) {
            let errors = records["errors"].to_string();
            return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
        }
        
        if let Some(records_array) = records["result"].as_array() {
            if let Some(record) = records_array.first() {
                if let Some(record_id) = record["id"].as_str() {
                    return Ok(Some(record_id.to_string()));
                }
            }
        }

        Ok(None)
    }

    async fn update_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        if let Some(record_id) = self.get_existing_record_id(zone_id, record_name, record_type, api_token).await? {
            // æ›´æ–°ç°æœ‰è®°å½•
            let update_url = format!("{}/{}", url, record_id);
            let update_data = serde_json::json!({
                "type": record_type,
                "name": record_name,
                "content": ip,
                "ttl": ttl,
                "proxied": proxy
            });

            let response = self.client
                .put(&update_url)
                .header("Authorization", format!("Bearer {}", api_token))
                .header("Content-Type", "application/json")
                .json(&update_data)
                .send()
                .await?;

            let result: serde_json::Value = response.json().await?;
            
            if result["success"].as_bool() == Some(true) {
                info!("âœ… Successfully updated DNS record: {} -> {}", record_name, ip);
            } else {
                let errors = result["errors"].to_string();
                error!("âŒ Failed to update DNS record {}: {}", record_name, errors);
                return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
            }
        } else {
            // åˆ›å»ºæ–°è®°å½•
            let create_data = serde_json::json!({
                "type": record_type,
                "name": record_name,
                "content": ip,
                "ttl": ttl,
                "proxied": proxy
            });

            let response = self.client
                .post(&url)
                .header("Authorization", format!("Bearer {}", api_token))
                .header("Content-Type", "application/json")
                .json(&create_data)
                .send()
                .await?;

            let result: serde_json::Value = response.json().await?;
            
            if result["success"].as_bool() == Some(true) {
                info!("âœ… Successfully created DNS record: {} -> {}", record_name, ip);
            } else {
                let errors = result["errors"].to_string();
                error!("âŒ Failed to create DNS record {}: {}", record_name, errors);
                return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
            }
        }

        Ok(())
    }
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let current_ip = client.get_current_ip(&config.dns_record_type).await?;
    info!("ğŸŒ Current public IP: {}", current_ip);

    let domain_names = config.get_domain_names();
    
    if domain_names.is_empty() {
        warn!("âš ï¸ No domain names configured");
        return Ok(());
    }

    info!("ğŸ“ Processing {} domain(s): {:?}", domain_names.len(), domain_names);

    for domain_name in domain_names {
        info!("ğŸ”„ Updating DNS record for: {}", domain_name);
        if let Err(e) = client.update_dns_record(
            &config.cf_zone_id,
            &domain_name,
            &config.dns_record_type,
            &config.cf_api_token,
            &current_ip,
            config.ttl,
            config.proxy,
        ).await {
            error!("âŒ Error updating domain {}: {}", domain_name, e);
        } else {
            info!("âœ… Successfully processed domain: {}", domain_name);
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("âŒ Failed to load configuration: {}", e);
            eprintln!("ğŸ’¡ Please check your environment variables:");
            eprintln!("   - CF_API_TOKEN");
            eprintln!("   - CF_ZONE_ID"); 
            eprintln!("   - DNS_RECORD_NAME");
            eprintln!("   - DNS_RECORD_TYPE (optional, defaults to A)");
            eprintln!("   - PROXY (optional, defaults to false)");
            eprintln!("   - TTL (optional, defaults to 120)");
            std::process::exit(1);
        }
    };
    
    info!("ğŸš€ Starting Cloudflare DDNS client");
    info!("â° Update interval: {} seconds", config.update_interval);
    info!("ğŸŒ Zone ID: {}", config.cf_zone_id);
    info!("ğŸ“‹ Record type: {}", config.dns_record_type);
    info("ğŸ›¡ï¸ Proxy enabled: {}", config.proxy);
    info!("â±ï¸ TTL: {} seconds", config.ttl);
    
    let domains = config.get_domain_names();
    info!("ğŸ¯ Monitoring {} domain(s): {:?}", domains.len(), domains);
    
    let client = CloudflareClient::new();
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ›´æ–°
    info!("ğŸ”„ Performing initial DDNS update...");
    if let Err(e) = run_ddns_update(&client, &config).await {
        error!("âŒ Initial DDNS update failed: {}", e);
    }
    
    info!("ğŸ”„ Starting update loop with {} second interval", config.update_interval);
    
    // ç„¶åæŒ‰é—´éš”å¾ªç¯æ‰§è¡Œ
    loop {
        sleep(Duration::from_secs(config.update_interval)).await;
        
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("âŒ DDNS update error: {}", e);
        }
    }
}
```

## 3. æ›´æ–° Dockerfile

```dockerfile
# æ„å»ºé˜¶æ®µ
FROM rust:1.90-alpine3.20 as builder

# å®‰è£…æ„å»ºä¾èµ–
RUN apk add --no-cache musl-dev openssl-dev openssl-libs-static pkgconfig

WORKDIR /app
COPY . .
RUN cargo build --release

# è¿è¡Œé˜¶æ®µ
FROM alpine:3.20

# å®‰è£…è¿è¡Œæ—¶ä¾èµ–
RUN apk add --no-cache ca-certificates libgcc

# åˆ›å»ºérootç”¨æˆ·
RUN adduser -D -u 1000 appuser
USER appuser

WORKDIR /app
COPY --from=builder /app/target/release/cloudflare-ddns /app/

# åˆ›å»ºå¯é€‰çš„envæ–‡ä»¶ç›®å½•
RUN mkdir -p /app/config

CMD ["/app/cloudflare-ddns"]
```

## 4. ç¯å¢ƒå˜é‡æ–‡ä»¶ç¤ºä¾‹

åˆ›å»º `config.env`ï¼š
```bash
# Cloudflare API configuration
# Replace with your API Token
CF_API_TOKEN="J1Hcxx"  
# Replace with your Zone ID
CF_ZONE_ID="af8axx"      
# The name of the record to be updated (supports multiple domains separated by commas)
DNS_RECORD_NAME="me.code.com,hn.code.com"    
# Record type, usually A or AAAA
DNS_RECORD_TYPE="A"             
# Enable Cloudflare proxy (optional, default: false)
PROXY=false
# TTL in seconds (optional, default: 120)
TTL=120
# Update interval in seconds (optional, default: 300)
UPDATE_INTERVAL=300
```

## 5. æ„å»ºå’Œè¿è¡Œ

### æ„å»º Docker é•œåƒï¼š
```bash
docker build -t cloudflare-ddns .
```

### è¿è¡Œå®¹å™¨ï¼š

**æ–¹å¼1ï¼šä½¿ç”¨ç¯å¢ƒå˜é‡æ–‡ä»¶**
```bash
docker run -d \
  --name ddns \
  --env-file config.env \
  cloudflare-ddns
```

**æ–¹å¼2ï¼šç›´æ¥è®¾ç½®ç¯å¢ƒå˜é‡**
```bash
docker run -d \
  --name ddns \
  -e CF_API_TOKEN="your_api_token" \
  -e CF_ZONE_ID="your_zone_id" \
  -e DNS_RECORD_NAME="me.code.com,hn.code.com" \
  -e DNS_RECORD_TYPE="A" \
  -e PROXY=false \
  -e TTL=120 \
  -e UPDATE_INTERVAL=300 \
  cloudflare-ddns
```

## 6. ä¸»è¦æ”¹è¿›

1. **å…¼å®¹ä½ çš„ç¯å¢ƒå˜é‡æ ¼å¼**ï¼šä½¿ç”¨ `CF_` å‰ç¼€çš„ç¯å¢ƒå˜é‡
2. **æ”¯æŒå¤šåŸŸå**ï¼šç”¨é€—å·åˆ†éš”å¤šä¸ªåŸŸå
3. **æ›´å¥½çš„é”™è¯¯å¤„ç†**ï¼šæ£€æŸ¥ Cloudflare API å“åº”ä¸­çš„ success å­—æ®µ
4. **æ›´æ¸…æ™°çš„æ—¥å¿—**ï¼šä½¿ç”¨è¡¨æƒ…ç¬¦å·å’Œç»“æ„åŒ–è¾“å‡º
5. **IPv6 æ”¯æŒ**ï¼šæ ¹æ®è®°å½•ç±»å‹è‡ªåŠ¨é€‰æ‹© IPv4/IPv6 æŸ¥è¯¢æœåŠ¡
6. **é…ç½®éªŒè¯**ï¼šå¯åŠ¨æ—¶æ£€æŸ¥å¿…è¦çš„ç¯å¢ƒå˜é‡

ç°åœ¨è¿™ä¸ªç‰ˆæœ¬å®Œå…¨å…¼å®¹ä½ æä¾›çš„ç¯å¢ƒå˜é‡æ ¼å¼ï¼ŒåŒæ—¶æ”¯æŒå¤šä¸ªåŸŸåçš„ DDNS æ›´æ–°ã€‚
åŸºäºä½ æä¾›çš„ Python ä»£ç ï¼Œæˆ‘æ¥é‡æ„ Rust ç‰ˆæœ¬ï¼Œä¿æŒç›¸åŒçš„åŠŸèƒ½å’Œé…ç½®æ–¹å¼ã€‚

## 1. æ›´æ–° Cargo.toml

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive"] }
dotenvy = "0.15"
```

## 2. ä¸»ç¨‹åº src/main.rs

```rust
use anyhow::Result;
use clap::Parser;
use config::{Config, Environment, File};
use log::{info, error, warn, debug};
use serde::Deserialize;
use std::time::Duration;
use tokio::time::sleep;
use chrono::{Utc, DateTime};
use std::collections::HashMap;

#[derive(Debug, Deserialize)]
struct AppConfig {
    // è°ƒåº¦é…ç½®
    update_interval: Option<u64>,
    
    // Cloudflare API é…ç½®
    cf_api_token: String,
    cf_zone_id: String,
    
    // DNS è®°å½•é…ç½®
    dns_record_name: String,
    #[serde(default = "default_record_type")]
    dns_record_type: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
    
    // ç½‘ç»œé…ç½®
    network: Option<String>,
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct CliArgs {
    /// Cloudflare API token
    #[arg(long)]
    cf_api_token: Option<String>,
    
    /// Cloudflare zone ID
    #[arg(long)]
    cf_zone_id: Option<String>,
    
    /// DNS record name (multiple domains separated by commas)
    #[arg(long)]
    dns_record_name: Option<String>,
    
    /// DNS record type
    #[arg(long, default_value = "A")]
    dns_record_type: Option<String>,
    
    /// Network information
    #[arg(long)]
    network: Option<String>,
    
    /// Run once and exit
    #[arg(long, default_value = "false")]
    once: bool,
}

fn default_record_type() -> String {
    "A".to_string()
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let mut cfg = Config::builder();

        // è®¾ç½®é»˜è®¤å€¼
        cfg = cfg.set_default("dns_record_type", "A")?;
        cfg = cfg.set_default("proxy", false)?;
        cfg = cfg.set_default("ttl", 120)?;

        // ä»å¯é€‰çš„ env æ–‡ä»¶åŠ è½½
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        } else {
            // å°è¯•åŠ è½½ .env æ–‡ä»¶
            let _ = dotenvy::dotenv();
        }

        // ä»ç¯å¢ƒå˜é‡åŠ è½½
        cfg = cfg.add_source(
            Environment::with_prefix("CF")
                .prefix_separator("_")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let mut app_config: AppConfig = config.try_deserialize()?;
        
        // åº”ç”¨å‘½ä»¤è¡Œå‚æ•°ï¼ˆè¦†ç›–ç¯å¢ƒå˜é‡å’Œé…ç½®æ–‡ä»¶ï¼‰
        let cli_args = CliArgs::parse();
        if let Some(token) = cli_args.cf_api_token {
            app_config.cf_api_token = token;
        }
        if let Some(zone_id) = cli_args.cf_zone_id {
            app_config.cf_zone_id = zone_id;
        }
        if let Some(record_name) = cli_args.dns_record_name {
            app_config.dns_record_name = record_name;
        }
        if let Some(record_type) = cli_args.dns_record_type {
            app_config.dns_record_type = record_type;
        }
        if let Some(network) = cli_args.network {
            app_config.network = Some(network);
        }
        
        Ok(app_config)
    }

    // è§£æå¤šä¸ªåŸŸå
    fn get_domain_names(&self) -> Vec<String> {
        self.dns_record_name
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect()
    }
    
    fn validate(&self) -> Result<()> {
        if self.cf_api_token.is_empty() {
            return Err(anyhow::anyhow!("CF_API_TOKEN must be set"));
        }
        if self.cf_zone_id.is_empty() {
            return Err(anyhow::anyhow!("CF_ZONE_ID must be set"));
        }
        if self.dns_record_name.is_empty() {
            return Err(anyhow::anyhow!("DNS_RECORD_NAME must be set"));
        }
        
        let domains = self.get_domain_names();
        if domains.is_empty() {
            return Err(anyhow::anyhow!("No valid domain names found in DNS_RECORD_NAME"));
        }
        
        Ok(())
    }
}

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new() -> Self {
        Self {
            client: reqwest::Client::builder()
                .timeout(Duration::from_secs(30))
                .build()
                .unwrap(),
        }
    }

    async fn get_public_ip(&self, record_type: &str) -> Result<String> {
        let services = match record_type {
            "AAAA" => vec![
                "https://api6.ipify.org",
                "https://ident.me",
                "https://ifconfig.me/ip",
            ],
            _ => vec![
                "https://api.ipify.org",
                "https://ident.me", 
                "https://ifconfig.me/ip",
            ],
        };
        
        for service in services {
            match self.client.get(service).timeout(Duration::from_secs(5)).send().await {
                Ok(response) => {
                    if response.status().is_success() {
                        let ip = response.text().await?.trim().to_string();
                        if !ip.is_empty() {
                            return Ok(ip);
                        }
                    }
                }
                Err(_) => continue,
            }
        }
        
        Err(anyhow::anyhow!("Unable to obtain public IP from any service"))
    }

    async fn get_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
    ) -> Result<Option<serde_json::Value>> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .query(&[("name", record_name), ("type", record_type)])
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() != Some(true) {
            let errors = result["errors"].to_string();
            return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
        }
        
        if let Some(records_array) = result["result"].as_array() {
            if let Some(record) = records_array.first() {
                return Ok(Some(record.clone()));
            }
        }

        Ok(None)
    }

    async fn update_dns_record(
        &self,
        zone_id: &str,
        record_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records/{}",
            zone_id, record_id
        );

        let update_data = serde_json::json!({
            "type": record_type,
            "name": record_name,
            "content": ip,
            "ttl": ttl,
            "proxied": proxy
        });

        let response = self.client
            .put(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .header("Content-Type", "application/json")
            .json(&update_data)
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() == Some(true) {
            info!("âœ… Successfully updated DNS record: {} -> {}", record_name, ip);
            Ok(())
        } else {
            let errors = result["errors"].to_string();
            Err(anyhow::anyhow!("Cloudflare API error: {}", errors))
        }
    }

    async fn add_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let create_data = serde_json::json!({
            "type": record_type,
            "name": record_name,
            "content": ip,
            "ttl": ttl,
            "proxied": proxy
        });

        let response = self.client
            .post(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .header("Content-Type", "application/json")
            .json(&create_data)
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() == Some(true) {
            info!("âœ… Successfully added DNS record: {} -> {}", record_name, ip);
            Ok(())
        } else {
            let errors = result["errors"].to_string();
            Err(anyhow::anyhow!("Cloudflare API error: {}", errors))
        }
    }
}

fn get_time_now() -> String {
    Utc::now().format("%Y-%m-%d %H:%M:%S").to_string()
}

fn info_step(msg: &str, length: usize, fillchar: char) {
    let msg_len = msg.len();
    let fill_length = (length - msg_len + 2) / 2;
    let padding = fillchar.to_string().repeat(fill_length);
    let padded_msg = format!("{}{}{}{}", padding, fillchar, msg, fillchar);
    println!("{}", &padded_msg[..length.min(padded_msg.len())]);
}

fn info_status(msg_body: &str, status: u8) {
    let icon = match status {
        0 => "âœ…",
        1 => "âŒ", 
        _ => "â„¹ï¸",
    };
    println!("{} {}", icon, msg_body);
}

async fn update_domains(client: &CloudflareClient, config: &AppConfig, current_ip: &str) -> Result<()> {
    let domain_names = config.get_domain_names();
    
    for domain in domain_names {
        let step_name = format!("get DNS record for {}", domain);
        info_step(&step_name, 60, '-');
        
        match client.get_dns_record(
            &config.cf_zone_id,
            &domain,
            &config.dns_record_type,
            &config.cf_api_token,
        ).await {
            Ok(Some(dns_record)) => {
                info_status(&format!("{} - DNS record {} found", get_time_now(), domain), 0);
                
                let record_ip = dns_record["content"].as_str().unwrap_or("");
                if record_ip != current_ip {
                    info_status(&format!("{} - IP change detected: Record IP {}, Current IP {} for {}", 
                        get_time_now(), record_ip, current_ip, domain), 0);
                    
                    let step_name = format!("update DNS record for {}", domain);
                    info_step(&step_name, 60, '-');
                    
                    let record_id = dns_record["id"].as_str().unwrap();
                    if let Err(e) = client.update_dns_record(
                        &config.cf_zone_id,
                        record_id,
                        &domain,
                        &config.dns_record_type,
                        &config.cf_api_token,
                        current_ip,
                        config.ttl,
                        config.proxy,
                    ).await {
                        error!("âŒ Failed to update domain {}: {}", domain, e);
                    } else {
                        info_status(&format!("{} - DNS record {} updated to {}", get_time_now(), domain, current_ip), 0);
                    }
                } else {
                    info_status(&format!("{} - IP not changed ({}) for {}", get_time_now(), current_ip, domain), 0);
                }
            }
            Ok(None) => {
                info_status(&format!("{} - DNS record {} not found, attempting to add", get_time_now(), domain), 1);
                
                if let Err(e) = client.add_dns_record(
                    &config.cf_zone_id,
                    &domain,
                    &config.dns_record_type,
                    &config.cf_api_token,
                    current_ip,
                    config.ttl,
                    config.proxy,
                ).await {
                    error!("âŒ Failed to add domain {}: {}", domain, e);
                } else {
                    info_status(&format!("{} - DNS record {} added successfully", get_time_now(), domain), 0);
                }
            }
            Err(e) => {
                error!("âŒ Failed to get DNS record for {}: {}", domain, e);
            }
        }
    }
    
    Ok(())
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let step_name = "get public IP";
    info_step(step_name, 60, '-');
    
    let current_ip = match client.get_public_ip(&config.dns_record_type).await {
        Ok(ip) => {
            info_status(&format!("{} - Public IP address {}", get_time_now(), ip), 0);
            ip
        }
        Err(e) => {
            info_status(&format!("{} - Failed to get public IP address: {}", get_time_now(), e), 1);
            return Err(e);
        }
    };
    
    update_domains(client, config, &current_ip).await
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    // åŠ è½½é…ç½®
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("âŒ Failed to load configuration: {}", e);
            eprintln!("ğŸ’¡ Configuration sources:");
            eprintln!("   - .env file (optional)");
            eprintln!("   - Environment variables with CF_ prefix");
            eprintln!("   - Command line arguments");
            eprintln!();
            eprintln!("ğŸ”§ Required variables:");
            eprintln!("   - CF_API_TOKEN: Cloudflare API token");
            eprintln!("   - CF_ZONE_ID: Cloudflare zone ID");
            eprintln!("   - DNS_RECORD_NAME: Domain name(s) separated by commas");
            std::process::exit(1);
        }
    };
    
    // éªŒè¯é…ç½®
    if let Err(e) = config.validate() {
        eprintln!("âŒ Configuration validation failed: {}", e);
        std::process::exit(1);
    }
    
    // æ˜¾ç¤ºé…ç½®ä¿¡æ¯
    info_step("Configuration", 60, '=');
    info_status(&format!("Zone ID: {}", config.cf_zone_id), 0);
    info_status(&format!("Record type: {}", config.dns_record_type), 0);
    info_status(&format!("Proxy enabled: {}", config.proxy), 0);
    info_status(&format!("TTL: {} seconds", config.ttl), 0);
    if let Some(network) = &config.network {
        info_status(&format!("Network: {}", network), 0);
    }
    
    let domains = config.get_domain_names();
    info_status(&format!("Monitoring {} domain(s): {:?}", domains.len(), domains), 0);
    
    let client = CloudflareClient::new();
    let cli_args = CliArgs::parse();
    
    // æ‰§è¡Œä¸€æ¬¡æ›´æ–°
    info_step("Initial DDNS Update", 60, '=');
    if let Err(e) = run_ddns_update(&client, &config).await {
        error!("âŒ Initial update failed: {}", e);
    }
    
    // å¦‚æœæŒ‡å®šäº† --once å‚æ•°ï¼Œåªæ‰§è¡Œä¸€æ¬¡å°±é€€å‡º
    if cli_args.once {
        info_step("Completed (one-time mode)", 60, '=');
        return Ok(());
    }
    
    // æŒç»­è¿è¡Œæ¨¡å¼
    let interval = config.update_interval.unwrap_or(300);
    info_step(&format!("Starting update loop ({}s interval)", interval), 60, '=');
    
    loop {
        sleep(Duration::from_secs(interval)).await;
        
        info_step("Scheduled Update", 60, '-');
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("âŒ Scheduled update failed: {}", e);
        }
    }
}
```

## 3. æ›´æ–° Dockerfile

```dockerfile
# æ„å»ºé˜¶æ®µ
FROM rust:1.90-alpine3.20 as builder

# å®‰è£…æ„å»ºä¾èµ–
RUN apk add --no-cache musl-dev openssl-dev openssl-libs-static pkgconfig

WORKDIR /app
COPY . .
RUN cargo build --release

# è¿è¡Œé˜¶æ®µ
FROM alpine:3.20

# å®‰è£…è¿è¡Œæ—¶ä¾èµ–
RUN apk add --no-cache ca-certificates libgcc

# åˆ›å»ºérootç”¨æˆ·
RUN adduser -D -u 1000 appuser
USER appuser

WORKDIR /app
COPY --from=builder /app/target/release/cloudflare-ddns /app/

CMD ["/app/cloudflare-ddns"]
```

## 4. ç¯å¢ƒå˜é‡æ–‡ä»¶ç¤ºä¾‹ .env

```bash
# Cloudflare API configuration
CF_API_TOKEN="your_api_token_here"
CF_ZONE_ID="your_zone_id_here"
DNS_RECORD_NAME="me.example.com,www.example.com,api.example.com"
DNS_RECORD_TYPE="A"
PROXY=false
TTL=120
UPDATE_INTERVAL=300
NETWORK="home"
```

## 5. ä½¿ç”¨æ–¹å¼

### æ„å»ºå’Œè¿è¡Œï¼š
```bash
# æ„å»º
docker build -t cloudflare-ddns .

# ä½¿ç”¨ç¯å¢ƒå˜é‡æ–‡ä»¶è¿è¡Œ
docker run -d --name ddns --env-file .env cloudflare-ddns

# ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°è¿è¡Œï¼ˆä¸€æ¬¡æ€§ï¼‰
docker run --rm cloudflare-ddns \
  --cf-api-token "your_token" \
  --cf-zone-id "your_zone_id" \
  --dns-record-name "example.com" \
  --once

# æ··åˆä½¿ç”¨ï¼ˆç¯å¢ƒå˜é‡ + å‘½ä»¤è¡Œè¦†ç›–ï¼‰
docker run -d --name ddns \
  -e CF_API_TOKEN="default_token" \
  cloudflare-ddns \
  --dns-record-name "custom.example.com"
```

## 6. ä¸»è¦ç‰¹æ€§

è¿™ä¸ª Rust ç‰ˆæœ¬å®Œå…¨å¤ç°äº† Python ç‰ˆæœ¬çš„åŠŸèƒ½ï¼š

1. **å¤šé…ç½®æºæ”¯æŒ**ï¼š
   - `.env` æ–‡ä»¶
   - ç¯å¢ƒå˜é‡ï¼ˆ`CF_` å‰ç¼€ï¼‰
   - å‘½ä»¤è¡Œå‚æ•°ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰

2. **å¤šåŸŸåæ”¯æŒ**ï¼šç”¨é€—å·åˆ†éš”å¤šä¸ªåŸŸå

3. **æ™ºèƒ½ IP è·å–**ï¼šä½¿ç”¨å¤šä¸ªæœåŠ¡ç¡®ä¿å¯é æ€§

4. **è‡ªåŠ¨è®°å½•åˆ›å»º**ï¼šå¦‚æœè®°å½•ä¸å­˜åœ¨åˆ™è‡ªåŠ¨åˆ›å»º

5. **çµæ´»çš„è¿è¡Œæ¨¡å¼**ï¼š
   - æŒç»­è¿è¡Œï¼ˆé»˜è®¤ï¼‰
   - ä¸€æ¬¡æ€§è¿è¡Œï¼ˆ`--once` å‚æ•°ï¼‰

6. **è¯¦ç»†çš„æ—¥å¿—è¾“å‡º**ï¼šä¸ Python ç‰ˆæœ¬ç›¸åŒçš„æ ¼å¼åŒ–è¾“å‡º

7. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

è¿™ä¸ªå®ç°ä¿æŒäº† Python ç‰ˆæœ¬çš„ç®€æ´æ€§å’ŒåŠŸèƒ½æ€§ï¼ŒåŒæ—¶è·å¾—äº† Rust çš„æ€§èƒ½å’Œå®‰å…¨æ€§ä¼˜åŠ¿ã€‚
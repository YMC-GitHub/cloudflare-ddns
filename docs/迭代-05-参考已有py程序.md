基于你提供的 Python 代码，我来重构 Rust 版本，保持相同的功能和配置方式。

## 1. 更新 Cargo.toml

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive"] }
dotenvy = "0.15"
```

## 2. 主程序 src/main.rs

```rust
use anyhow::Result;
use clap::Parser;
use config::{Config, Environment, File};
use log::{info, error, warn, debug};
use serde::Deserialize;
use std::time::Duration;
use tokio::time::sleep;
use chrono::{Utc, DateTime};
use std::collections::HashMap;

#[derive(Debug, Deserialize)]
struct AppConfig {
    // 调度配置
    update_interval: Option<u64>,
    
    // Cloudflare API 配置
    cf_api_token: String,
    cf_zone_id: String,
    
    // DNS 记录配置
    dns_record_name: String,
    #[serde(default = "default_record_type")]
    dns_record_type: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
    
    // 网络配置
    network: Option<String>,
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct CliArgs {
    /// Cloudflare API token
    #[arg(long)]
    cf_api_token: Option<String>,
    
    /// Cloudflare zone ID
    #[arg(long)]
    cf_zone_id: Option<String>,
    
    /// DNS record name (multiple domains separated by commas)
    #[arg(long)]
    dns_record_name: Option<String>,
    
    /// DNS record type
    #[arg(long, default_value = "A")]
    dns_record_type: Option<String>,
    
    /// Network information
    #[arg(long)]
    network: Option<String>,
    
    /// Run once and exit
    #[arg(long, default_value = "false")]
    once: bool,
}

fn default_record_type() -> String {
    "A".to_string()
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let mut cfg = Config::builder();

        // 设置默认值
        cfg = cfg.set_default("dns_record_type", "A")?;
        cfg = cfg.set_default("proxy", false)?;
        cfg = cfg.set_default("ttl", 120)?;

        // 从可选的 env 文件加载
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        } else {
            // 尝试加载 .env 文件
            let _ = dotenvy::dotenv();
        }

        // 从环境变量加载
        cfg = cfg.add_source(
            Environment::with_prefix("CF")
                .prefix_separator("_")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let mut app_config: AppConfig = config.try_deserialize()?;
        
        // 应用命令行参数（覆盖环境变量和配置文件）
        let cli_args = CliArgs::parse();
        if let Some(token) = cli_args.cf_api_token {
            app_config.cf_api_token = token;
        }
        if let Some(zone_id) = cli_args.cf_zone_id {
            app_config.cf_zone_id = zone_id;
        }
        if let Some(record_name) = cli_args.dns_record_name {
            app_config.dns_record_name = record_name;
        }
        if let Some(record_type) = cli_args.dns_record_type {
            app_config.dns_record_type = record_type;
        }
        if let Some(network) = cli_args.network {
            app_config.network = Some(network);
        }
        
        Ok(app_config)
    }

    // 解析多个域名
    fn get_domain_names(&self) -> Vec<String> {
        self.dns_record_name
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect()
    }
    
    fn validate(&self) -> Result<()> {
        if self.cf_api_token.is_empty() {
            return Err(anyhow::anyhow!("CF_API_TOKEN must be set"));
        }
        if self.cf_zone_id.is_empty() {
            return Err(anyhow::anyhow!("CF_ZONE_ID must be set"));
        }
        if self.dns_record_name.is_empty() {
            return Err(anyhow::anyhow!("DNS_RECORD_NAME must be set"));
        }
        
        let domains = self.get_domain_names();
        if domains.is_empty() {
            return Err(anyhow::anyhow!("No valid domain names found in DNS_RECORD_NAME"));
        }
        
        Ok(())
    }
}

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new() -> Self {
        Self {
            client: reqwest::Client::builder()
                .timeout(Duration::from_secs(30))
                .build()
                .unwrap(),
        }
    }

    async fn get_public_ip(&self, record_type: &str) -> Result<String> {
        let services = match record_type {
            "AAAA" => vec![
                "https://api6.ipify.org",
                "https://ident.me",
                "https://ifconfig.me/ip",
            ],
            _ => vec![
                "https://api.ipify.org",
                "https://ident.me", 
                "https://ifconfig.me/ip",
            ],
        };
        
        for service in services {
            match self.client.get(service).timeout(Duration::from_secs(5)).send().await {
                Ok(response) => {
                    if response.status().is_success() {
                        let ip = response.text().await?.trim().to_string();
                        if !ip.is_empty() {
                            return Ok(ip);
                        }
                    }
                }
                Err(_) => continue,
            }
        }
        
        Err(anyhow::anyhow!("Unable to obtain public IP from any service"))
    }

    async fn get_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
    ) -> Result<Option<serde_json::Value>> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .query(&[("name", record_name), ("type", record_type)])
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() != Some(true) {
            let errors = result["errors"].to_string();
            return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
        }
        
        if let Some(records_array) = result["result"].as_array() {
            if let Some(record) = records_array.first() {
                return Ok(Some(record.clone()));
            }
        }

        Ok(None)
    }

    async fn update_dns_record(
        &self,
        zone_id: &str,
        record_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records/{}",
            zone_id, record_id
        );

        let update_data = serde_json::json!({
            "type": record_type,
            "name": record_name,
            "content": ip,
            "ttl": ttl,
            "proxied": proxy
        });

        let response = self.client
            .put(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .header("Content-Type", "application/json")
            .json(&update_data)
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() == Some(true) {
            info!("✅ Successfully updated DNS record: {} -> {}", record_name, ip);
            Ok(())
        } else {
            let errors = result["errors"].to_string();
            Err(anyhow::anyhow!("Cloudflare API error: {}", errors))
        }
    }

    async fn add_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let create_data = serde_json::json!({
            "type": record_type,
            "name": record_name,
            "content": ip,
            "ttl": ttl,
            "proxied": proxy
        });

        let response = self.client
            .post(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .header("Content-Type", "application/json")
            .json(&create_data)
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() == Some(true) {
            info!("✅ Successfully added DNS record: {} -> {}", record_name, ip);
            Ok(())
        } else {
            let errors = result["errors"].to_string();
            Err(anyhow::anyhow!("Cloudflare API error: {}", errors))
        }
    }
}

fn get_time_now() -> String {
    Utc::now().format("%Y-%m-%d %H:%M:%S").to_string()
}

fn info_step(msg: &str, length: usize, fillchar: char) {
    let msg_len = msg.len();
    let fill_length = (length - msg_len + 2) / 2;
    let padding = fillchar.to_string().repeat(fill_length);
    let padded_msg = format!("{}{}{}{}", padding, fillchar, msg, fillchar);
    println!("{}", &padded_msg[..length.min(padded_msg.len())]);
}

fn info_status(msg_body: &str, status: u8) {
    let icon = match status {
        0 => "✅",
        1 => "❌", 
        _ => "ℹ️",
    };
    println!("{} {}", icon, msg_body);
}

async fn update_domains(client: &CloudflareClient, config: &AppConfig, current_ip: &str) -> Result<()> {
    let domain_names = config.get_domain_names();
    
    for domain in domain_names {
        let step_name = format!("get DNS record for {}", domain);
        info_step(&step_name, 60, '-');
        
        match client.get_dns_record(
            &config.cf_zone_id,
            &domain,
            &config.dns_record_type,
            &config.cf_api_token,
        ).await {
            Ok(Some(dns_record)) => {
                info_status(&format!("{} - DNS record {} found", get_time_now(), domain), 0);
                
                let record_ip = dns_record["content"].as_str().unwrap_or("");
                if record_ip != current_ip {
                    info_status(&format!("{} - IP change detected: Record IP {}, Current IP {} for {}", 
                        get_time_now(), record_ip, current_ip, domain), 0);
                    
                    let step_name = format!("update DNS record for {}", domain);
                    info_step(&step_name, 60, '-');
                    
                    let record_id = dns_record["id"].as_str().unwrap();
                    if let Err(e) = client.update_dns_record(
                        &config.cf_zone_id,
                        record_id,
                        &domain,
                        &config.dns_record_type,
                        &config.cf_api_token,
                        current_ip,
                        config.ttl,
                        config.proxy,
                    ).await {
                        error!("❌ Failed to update domain {}: {}", domain, e);
                    } else {
                        info_status(&format!("{} - DNS record {} updated to {}", get_time_now(), domain, current_ip), 0);
                    }
                } else {
                    info_status(&format!("{} - IP not changed ({}) for {}", get_time_now(), current_ip, domain), 0);
                }
            }
            Ok(None) => {
                info_status(&format!("{} - DNS record {} not found, attempting to add", get_time_now(), domain), 1);
                
                if let Err(e) = client.add_dns_record(
                    &config.cf_zone_id,
                    &domain,
                    &config.dns_record_type,
                    &config.cf_api_token,
                    current_ip,
                    config.ttl,
                    config.proxy,
                ).await {
                    error!("❌ Failed to add domain {}: {}", domain, e);
                } else {
                    info_status(&format!("{} - DNS record {} added successfully", get_time_now(), domain), 0);
                }
            }
            Err(e) => {
                error!("❌ Failed to get DNS record for {}: {}", domain, e);
            }
        }
    }
    
    Ok(())
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let step_name = "get public IP";
    info_step(step_name, 60, '-');
    
    let current_ip = match client.get_public_ip(&config.dns_record_type).await {
        Ok(ip) => {
            info_status(&format!("{} - Public IP address {}", get_time_now(), ip), 0);
            ip
        }
        Err(e) => {
            info_status(&format!("{} - Failed to get public IP address: {}", get_time_now(), e), 1);
            return Err(e);
        }
    };
    
    update_domains(client, config, &current_ip).await
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    // 加载配置
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("❌ Failed to load configuration: {}", e);
            eprintln!("💡 Configuration sources:");
            eprintln!("   - .env file (optional)");
            eprintln!("   - Environment variables with CF_ prefix");
            eprintln!("   - Command line arguments");
            eprintln!();
            eprintln!("🔧 Required variables:");
            eprintln!("   - CF_API_TOKEN: Cloudflare API token");
            eprintln!("   - CF_ZONE_ID: Cloudflare zone ID");
            eprintln!("   - DNS_RECORD_NAME: Domain name(s) separated by commas");
            std::process::exit(1);
        }
    };
    
    // 验证配置
    if let Err(e) = config.validate() {
        eprintln!("❌ Configuration validation failed: {}", e);
        std::process::exit(1);
    }
    
    // 显示配置信息
    info_step("Configuration", 60, '=');
    info_status(&format!("Zone ID: {}", config.cf_zone_id), 0);
    info_status(&format!("Record type: {}", config.dns_record_type), 0);
    info_status(&format!("Proxy enabled: {}", config.proxy), 0);
    info_status(&format!("TTL: {} seconds", config.ttl), 0);
    if let Some(network) = &config.network {
        info_status(&format!("Network: {}", network), 0);
    }
    
    let domains = config.get_domain_names();
    info_status(&format!("Monitoring {} domain(s): {:?}", domains.len(), domains), 0);
    
    let client = CloudflareClient::new();
    let cli_args = CliArgs::parse();
    
    // 执行一次更新
    info_step("Initial DDNS Update", 60, '=');
    if let Err(e) = run_ddns_update(&client, &config).await {
        error!("❌ Initial update failed: {}", e);
    }
    
    // 如果指定了 --once 参数，只执行一次就退出
    if cli_args.once {
        info_step("Completed (one-time mode)", 60, '=');
        return Ok(());
    }
    
    // 持续运行模式
    let interval = config.update_interval.unwrap_or(300);
    info_step(&format!("Starting update loop ({}s interval)", interval), 60, '=');
    
    loop {
        sleep(Duration::from_secs(interval)).await;
        
        info_step("Scheduled Update", 60, '-');
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("❌ Scheduled update failed: {}", e);
        }
    }
}
```

## 3. 更新 Dockerfile

```dockerfile
# 构建阶段
FROM rust:1.90-alpine3.20 as builder

# 安装构建依赖
RUN apk add --no-cache musl-dev openssl-dev openssl-libs-static pkgconfig

WORKDIR /app
COPY . .
RUN cargo build --release

# 运行阶段
FROM alpine:3.20

# 安装运行时依赖
RUN apk add --no-cache ca-certificates libgcc

# 创建非root用户
RUN adduser -D -u 1000 appuser
USER appuser

WORKDIR /app
COPY --from=builder /app/target/release/cloudflare-ddns /app/

CMD ["/app/cloudflare-ddns"]
```

## 4. 环境变量文件示例 .env

```bash
# Cloudflare API configuration
CF_API_TOKEN="your_api_token_here"
CF_ZONE_ID="your_zone_id_here"
DNS_RECORD_NAME="me.example.com,www.example.com,api.example.com"
DNS_RECORD_TYPE="A"
PROXY=false
TTL=120
UPDATE_INTERVAL=300
NETWORK="home"
```

## 5. 使用方式

### 构建和运行：
```bash
# 构建
docker build -t cloudflare-ddns .

# 使用环境变量文件运行
docker run -d --name ddns --env-file .env cloudflare-ddns

# 使用命令行参数运行（一次性）
docker run --rm cloudflare-ddns \
  --cf-api-token "your_token" \
  --cf-zone-id "your_zone_id" \
  --dns-record-name "example.com" \
  --once

# 混合使用（环境变量 + 命令行覆盖）
docker run -d --name ddns \
  -e CF_API_TOKEN="default_token" \
  cloudflare-ddns \
  --dns-record-name "custom.example.com"
```

## 6. 主要特性

这个 Rust 版本完全复现了 Python 版本的功能：

1. **多配置源支持**：
   - `.env` 文件
   - 环境变量（`CF_` 前缀）
   - 命令行参数（最高优先级）

2. **多域名支持**：用逗号分隔多个域名

3. **智能 IP 获取**：使用多个服务确保可靠性

4. **自动记录创建**：如果记录不存在则自动创建

5. **灵活的运行模式**：
   - 持续运行（默认）
   - 一次性运行（`--once` 参数）

6. **详细的日志输出**：与 Python 版本相同的格式化输出

7. **错误处理**：完善的错误处理和重试机制

这个实现保持了 Python 版本的简洁性和功能性，同时获得了 Rust 的性能和安全性优势。
æˆ‘æ¥ä¸ºé¡¹ç›®æ·»åŠ è·¨å¹³å°æ”¯æŒå’Œç¼–è¯‘è¯´æ˜ã€‚

## 1. æ›´æ–° Cargo.toml æ·»åŠ è·¨å¹³å°ç‰¹æ€§

```toml
[package]
name = "cloudflare-ddns"
version = "0.1.0"
edition = "2021"
description = "A cross-platform Cloudflare DDNS client written in Rust"
authors = ["Your Name <your.email@example.com>"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/yourusername/cloudflare-ddns"
readme = "README.md"
keywords = ["ddns", "cloudflare", "dns", "dynamic-dns"]
categories = ["command-line-utilities", "network-programming"]

# è·¨å¹³å°ç‰¹æ€§é…ç½®
[package.metadata]
platforms = ["x86_64-unknown-linux-gnu", "x86_64-pc-windows-msvc", "x86_64-apple-darwin", "aarch64-unknown-linux-gnu", "aarch64-apple-darwin"]

# é’ˆå¯¹ä¸åŒå¹³å°çš„ç‰¹æ€§
[features]
default = ["native-tls"]
# ä½¿ç”¨åŸç”ŸTLSï¼ˆå„å¹³å°é»˜è®¤ï¼‰
native-tls = ["reqwest/native-tls"]
# ä½¿ç”¨Rust TLSï¼ˆæ›´å°çš„äºŒè¿›åˆ¶å¤§å°ï¼‰
rustls = ["reqwest/rustls-tls"]

# å¹³å°ç‰¹å®šç‰¹æ€§
windows = []
unix = []
linux = []
macos = []

[dependencies]
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.13"
anyhow = "1.0"
log = "0.4"
env_logger = "0.10"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive"] }
dotenvy = "0.15"

# æ¡ä»¶ç¼–è¯‘ä¾èµ–
[target.'cfg(windows)'.dependencies]
winapi = { version = "0.3", features = ["winbase"] }

[target.'cfg(unix)'.dependencies]
libc = "0.2"

# å¼€å‘ä¾èµ–
[dev-dependencies]
tempfile = "3.3"
```

## 2. æ›´æ–°ä¸»ç¨‹åºæ·»åŠ å¹³å°ç‰¹å®šä»£ç 

```rust
//! Cloudflare DDNS Client
//!
//! A cross-platform dynamic DNS updater for Cloudflare.
//! Supports Windows, Linux, macOS on x86_64 and AArch64 architectures.
//!
//! # Features
//! - Multi-platform support (Windows, Linux, macOS)
//! - Multiple configuration sources (env file, environment variables, CLI args)
//! - Multiple domain support
//! - IPv4 and IPv6 support
//! - Automatic record creation
//! - Both one-time and continuous operation modes

use anyhow::Result;
use clap::Parser;
use config::{Config, Environment, File};
use log::{info, error, warn, debug};
use serde::Deserialize;
use std::time::Duration;
use tokio::time::sleep;
use chrono::{Utc, DateTime};
use std::collections::HashMap;

/// Platform information
#[derive(Debug)]
struct PlatformInfo {
    os: String,
    arch: String,
    family: String,
}

impl PlatformInfo {
    fn new() -> Self {
        Self {
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),
            family: std::env::consts::FAMILY.to_string(),
        }
    }
    
    fn display(&self) -> String {
        format!("{}-{}", self.os, self.arch)
    }
}

#[cfg(windows)]
/// Windows specific functionality
mod windows {
    use super::*;
    use winapi::um::winbase::GetComputerNameA;
    use std::ptr;
    use std::ffi::CString;
    
    pub fn get_host_identifier() -> Result<String> {
        // Windows: ä½¿ç”¨è®¡ç®—æœºåä½œä¸ºæ ‡è¯†
        unsafe {
            let mut buffer: [i8; 256] = [0; 256];
            let mut size = buffer.len() as u32;
            
            if GetComputerNameA(buffer.as_mut_ptr(), &mut size) != 0 {
                let hostname = CString::from_vec_unchecked(
                    buffer[..size as usize].iter().map(|&c| c as u8).collect()
                );
                Ok(hostname.to_string_lossy().into_owned())
            } else {
                Ok("unknown-windows-host".to_string())
            }
        }
    }
}

#[cfg(unix)]
/// Unix-like systems specific functionality (Linux, macOS, etc.)
mod unix {
    use super::*;
    use std::process::Command;
    
    pub fn get_host_identifier() -> Result<String> {
        // Unix: ä½¿ç”¨ hostname å‘½ä»¤
        match Command::new("hostname").output() {
            Ok(output) if output.status.success() => {
                let hostname = String::from_utf8_lossy(&output.stdout).trim().to_string();
                if hostname.is_empty() {
                    Ok("unknown-unix-host".to_string())
                } else {
                    Ok(hostname)
                }
            }
            _ => Ok("unknown-unix-host".to_string()),
        }
    }
}

#[cfg(not(any(windows, unix)))]
/// Fallback for other platforms
mod other {
    use super::*;
    
    pub fn get_host_identifier() -> Result<String> {
        Ok("unknown-platform".to_string())
    }
}

/// Get platform-specific host identifier
fn get_host_identifier() -> Result<String> {
    #[cfg(windows)]
    return windows::get_host_identifier();
    #[cfg(unix)]
    return unix::get_host_identifier();
    #[cfg(not(any(windows, unix)))]
    return other::get_host_identifier();
}

#[derive(Debug, Deserialize)]
struct AppConfig {
    // è°ƒåº¦é…ç½®
    update_interval: Option<u64>,
    
    // Cloudflare API é…ç½®
    cf_api_token: String,
    cf_zone_id: String,
    
    // DNS è®°å½•é…ç½®
    dns_record_name: String,
    #[serde(default = "default_record_type")]
    dns_record_type: String,
    #[serde(default = "default_proxy")]
    proxy: bool,
    #[serde(default = "default_ttl")]
    ttl: u32,
    
    // ç½‘ç»œé…ç½®
    network: Option<String>,
    
    // å¹³å°ç‰¹å®šé…ç½®
    #[serde(default)]
    platform_identifier: String,
}

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about = "Cross-platform Cloudflare DDNS client",
    long_about = "A dynamic DNS updater for Cloudflare that works on Windows, Linux, and macOS.\nSupports multiple domains and both IPv4 and IPv6 addresses."
)]
struct CliArgs {
    /// Cloudflare API token
    #[arg(long, env = "CF_API_TOKEN")]
    cf_api_token: Option<String>,
    
    /// Cloudflare zone ID
    #[arg(long, env = "CF_ZONE_ID")]
    cf_zone_id: Option<String>,
    
    /// DNS record name (multiple domains separated by commas)
    #[arg(long, env = "DNS_RECORD_NAME")]
    dns_record_name: Option<String>,
    
    /// DNS record type [default: A]
    #[arg(long, default_value = "A")]
    dns_record_type: Option<String>,
    
    /// Enable Cloudflare proxy [default: false]
    #[arg(long, default_value = "false")]
    proxy: bool,
    
    /// TTL in seconds [default: 120]
    #[arg(long, default_value = "120")]
    ttl: u32,
    
    /// Network identifier
    #[arg(long, env = "NETWORK")]
    network: Option<String>,
    
    /// Update interval in seconds [default: 300]
    #[arg(long)]
    update_interval: Option<u64>,
    
    /// Run once and exit
    #[arg(long, default_value = "false")]
    once: bool,
    
    /// Show platform information
    #[arg(long, default_value = "false")]
    show_platform: bool,
    
    /// Use RustLS instead of native TLS (may reduce binary size)
    #[arg(long, default_value = "false")]
    use_rustls: bool,
}

fn default_record_type() -> String {
    "A".to_string()
}

fn default_proxy() -> bool {
    false
}

fn default_ttl() -> u32 {
    120 // 2 minutes
}

impl AppConfig {
    fn new() -> Result<Self> {
        let platform = PlatformInfo::new();
        let host_identifier = get_host_identifier().unwrap_or_else(|_| "unknown".to_string());
        
        let mut cfg = Config::builder();

        // è®¾ç½®é»˜è®¤å€¼
        cfg = cfg.set_default("dns_record_type", "A")?;
        cfg = cfg.set_default("proxy", false)?;
        cfg = cfg.set_default("ttl", 120)?;
        cfg = cfg.set_default("platform_identifier", host_identifier)?;

        // ä»å¯é€‰çš„ env æ–‡ä»¶åŠ è½½
        if let Ok(env_file) = std::env::var("ENV_FILE") {
            cfg = cfg.add_source(File::with_name(&env_file).required(false));
        } else {
            // å°è¯•åŠ è½½ .env æ–‡ä»¶
            let _ = dotenvy::dotenv();
        }

        // ä»ç¯å¢ƒå˜é‡åŠ è½½
        cfg = cfg.add_source(
            Environment::with_prefix("CF")
                .prefix_separator("_")
                .ignore_empty(true)
                .try_parsing(true)
        );

        let config = cfg.build()?;
        let mut app_config: AppConfig = config.try_deserialize()?;
        
        // åº”ç”¨å‘½ä»¤è¡Œå‚æ•°ï¼ˆè¦†ç›–ç¯å¢ƒå˜é‡å’Œé…ç½®æ–‡ä»¶ï¼‰
        let cli_args = CliArgs::parse();
        
        if cli_args.show_platform {
            println!("Platform: {}", platform.display());
            println!("OS: {}", platform.os);
            println!("Architecture: {}", platform.arch);
            println!("Family: {}", platform.family);
            std::process::exit(0);
        }
        
        if let Some(token) = cli_args.cf_api_token {
            app_config.cf_api_token = token;
        }
        if let Some(zone_id) = cli_args.cf_zone_id {
            app_config.cf_zone_id = zone_id;
        }
        if let Some(record_name) = cli_args.dns_record_name {
            app_config.dns_record_name = record_name;
        }
        if let Some(record_type) = cli_args.dns_record_type {
            app_config.dns_record_type = record_type;
        }
        if let Some(network) = cli_args.network {
            app_config.network = Some(network);
        }
        if let Some(interval) = cli_args.update_interval {
            app_config.update_interval = Some(interval);
        }
        
        app_config.proxy = cli_args.proxy;
        app_config.ttl = cli_args.ttl;
        
        Ok(app_config)
    }

    // è§£æå¤šä¸ªåŸŸå
    fn get_domain_names(&self) -> Vec<String> {
        self.dns_record_name
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect()
    }
    
    fn validate(&self) -> Result<()> {
        if self.cf_api_token.is_empty() {
            return Err(anyhow::anyhow!("CF_API_TOKEN must be set"));
        }
        if self.cf_zone_id.is_empty() {
            return Err(anyhow::anyhow!("CF_ZONE_ID must be set"));
        }
        if self.dns_record_name.is_empty() {
            return Err(anyhow::anyhow!("DNS_RECORD_NAME must be set"));
        }
        
        let domains = self.get_domain_names();
        if domains.is_empty() {
            return Err(anyhow::anyhow!("No valid domain names found in DNS_RECORD_NAME"));
        }
        
        if self.ttl < 1 || self.ttl > 86400 {
            return Err(anyhow::anyhow!("TTL must be between 1 and 86400 seconds"));
        }
        
        Ok(())
    }
}

// å…¶ä½™ä»£ç ä¿æŒä¸å˜...
// [ä¹‹å‰çš„ CloudflareClient, info_step, info_status, update_domains, run_ddns_update ç­‰å‡½æ•°]

struct CloudflareClient {
    client: reqwest::Client,
}

impl CloudflareClient {
    fn new(use_rustls: bool) -> Self {
        let client_builder = reqwest::Client::builder()
            .timeout(Duration::from_secs(30));
            
        // æ ¹æ®å¹³å°å’Œé€‰æ‹©ä½¿ç”¨ä¸åŒçš„ TLS åç«¯
        #[cfg(feature = "rustls")]
        let client_builder = if use_rustls {
            client_builder.use_rustls_tls()
        } else {
            client_builder
        };
        
        Self {
            client: client_builder.build().unwrap(),
        }
    }

    async fn get_public_ip(&self, record_type: &str) -> Result<String> {
        let services = match record_type {
            "AAAA" => vec![
                "https://api6.ipify.org",
                "https://ident.me",
                "https://ifconfig.me/ip",
            ],
            _ => vec![
                "https://api.ipify.org",
                "https://ident.me", 
                "https://ifconfig.me/ip",
            ],
        };
        
        for service in services {
            match self.client.get(service).timeout(Duration::from_secs(5)).send().await {
                Ok(response) => {
                    if response.status().is_success() {
                        let ip = response.text().await?.trim().to_string();
                        if !ip.is_empty() {
                            return Ok(ip);
                        }
                    }
                }
                Err(_) => continue,
            }
        }
        
        Err(anyhow::anyhow!("Unable to obtain public IP from any service"))
    }

    // å…¶ä½™ CloudflareClient æ–¹æ³•ä¿æŒä¸å˜...
    async fn get_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
    ) -> Result<Option<serde_json::Value>> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .query(&[("name", record_name), ("type", record_type)])
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() != Some(true) {
            let errors = result["errors"].to_string();
            return Err(anyhow::anyhow!("Cloudflare API error: {}", errors));
        }
        
        if let Some(records_array) = result["result"].as_array() {
            if let Some(record) = records_array.first() {
                return Ok(Some(record.clone()));
            }
        }

        Ok(None)
    }

    async fn update_dns_record(
        &self,
        zone_id: &str,
        record_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records/{}",
            zone_id, record_id
        );

        let update_data = serde_json::json!({
            "type": record_type,
            "name": record_name,
            "content": ip,
            "ttl": ttl,
            "proxied": proxy
        });

        let response = self.client
            .put(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .header("Content-Type", "application/json")
            .json(&update_data)
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() == Some(true) {
            info!("âœ… Successfully updated DNS record: {} -> {}", record_name, ip);
            Ok(())
        } else {
            let errors = result["errors"].to_string();
            Err(anyhow::anyhow!("Cloudflare API error: {}", errors))
        }
    }

    async fn add_dns_record(
        &self,
        zone_id: &str,
        record_name: &str,
        record_type: &str,
        api_token: &str,
        ip: &str,
        ttl: u32,
        proxy: bool,
    ) -> Result<()> {
        let url = format!(
            "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
            zone_id
        );

        let create_data = serde_json::json!({
            "type": record_type,
            "name": record_name,
            "content": ip,
            "ttl": ttl,
            "proxied": proxy
        });

        let response = self.client
            .post(&url)
            .header("Authorization", format!("Bearer {}", api_token))
            .header("Content-Type", "application/json")
            .json(&create_data)
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        
        if result["success"].as_bool() == Some(true) {
            info!("âœ… Successfully added DNS record: {} -> {}", record_name, ip);
            Ok(())
        } else {
            let errors = result["errors"].to_string();
            Err(anyhow::anyhow!("Cloudflare API error: {}", errors))
        }
    }
}

fn get_time_now() -> String {
    Utc::now().format("%Y-%m-%d %H:%M:%S").to_string()
}

fn info_step(msg: &str, length: usize, fillchar: char) {
    let msg_len = msg.len();
    let fill_length = (length - msg_len + 2) / 2;
    let padding = fillchar.to_string().repeat(fill_length);
    let padded_msg = format!("{}{}{}{}", padding, fillchar, msg, fillchar);
    println!("{}", &padded_msg[..length.min(padded_msg.len())]);
}

fn info_status(msg_body: &str, status: u8) {
    let icon = match status {
        0 => "âœ…",
        1 => "âŒ", 
        _ => "â„¹ï¸",
    };
    println!("{} {}", icon, msg_body);
}

async fn update_domains(client: &CloudflareClient, config: &AppConfig, current_ip: &str) -> Result<()> {
    let domain_names = config.get_domain_names();
    
    for domain in domain_names {
        let step_name = format!("get DNS record for {}", domain);
        info_step(&step_name, 60, '-');
        
        match client.get_dns_record(
            &config.cf_zone_id,
            &domain,
            &config.dns_record_type,
            &config.cf_api_token,
        ).await {
            Ok(Some(dns_record)) => {
                info_status(&format!("{} - DNS record {} found", get_time_now(), domain), 0);
                
                let record_ip = dns_record["content"].as_str().unwrap_or("");
                if record_ip != current_ip {
                    info_status(&format!("{} - IP change detected: Record IP {}, Current IP {} for {}", 
                        get_time_now(), record_ip, current_ip, domain), 0);
                    
                    let step_name = format!("update DNS record for {}", domain);
                    info_step(&step_name, 60, '-');
                    
                    let record_id = dns_record["id"].as_str().unwrap();
                    if let Err(e) = client.update_dns_record(
                        &config.cf_zone_id,
                        record_id,
                        &domain,
                        &config.dns_record_type,
                        &config.cf_api_token,
                        current_ip,
                        config.ttl,
                        config.proxy,
                    ).await {
                        error!("âŒ Failed to update domain {}: {}", domain, e);
                    } else {
                        info_status(&format!("{} - DNS record {} updated to {}", get_time_now(), domain, current_ip), 0);
                    }
                } else {
                    info_status(&format!("{} - IP not changed ({}) for {}", get_time_now(), current_ip, domain), 0);
                }
            }
            Ok(None) => {
                info_status(&format!("{} - DNS record {} not found, attempting to add", get_time_now(), domain), 1);
                
                if let Err(e) = client.add_dns_record(
                    &config.cf_zone_id,
                    &domain,
                    &config.dns_record_type,
                    &config.cf_api_token,
                    current_ip,
                    config.ttl,
                    config.proxy,
                ).await {
                    error!("âŒ Failed to add domain {}: {}", domain, e);
                } else {
                    info_status(&format!("{} - DNS record {} added successfully", get_time_now(), domain), 0);
                }
            }
            Err(e) => {
                error!("âŒ Failed to get DNS record for {}: {}", domain, e);
            }
        }
    }
    
    Ok(())
}

async fn run_ddns_update(client: &CloudflareClient, config: &AppConfig) -> Result<()> {
    let step_name = "get public IP";
    info_step(step_name, 60, '-');
    
    let current_ip = match client.get_public_ip(&config.dns_record_type).await {
        Ok(ip) => {
            info_status(&format!("{} - Public IP address {}", get_time_now(), ip), 0);
            ip
        }
        Err(e) => {
            info_status(&format!("{} - Failed to get public IP address: {}", get_time_now(), e), 1);
            return Err(e);
        }
    };
    
    update_domains(client, config, &current_ip).await
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let platform = PlatformInfo::new();
    info!("ğŸš€ Starting Cloudflare DDNS Client on {}", platform.display());
    
    // åŠ è½½é…ç½®
    let config = match AppConfig::new() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("âŒ Failed to load configuration: {}", e);
            eprintln!("ğŸ’¡ Configuration sources:");
            eprintln!("   - .env file (optional)");
            eprintln!("   - Environment variables with CF_ prefix");
            eprintln!("   - Command line arguments");
            eprintln!();
            eprintln!("ğŸ”§ Required variables:");
            eprintln!("   - CF_API_TOKEN: Cloudflare API token");
            eprintln!("   - CF_ZONE_ID: Cloudflare zone ID");
            eprintln!("   - DNS_RECORD_NAME: Domain name(s) separated by commas");
            std::process::exit(1);
        }
    };
    
    // éªŒè¯é…ç½®
    if let Err(e) = config.validate() {
        eprintln!("âŒ Configuration validation failed: {}", e);
        std::process::exit(1);
    }
    
    let cli_args = CliArgs::parse();
    
    // æ˜¾ç¤ºé…ç½®ä¿¡æ¯
    info_step("Configuration", 60, '=');
    info_status(&format!("Platform: {}", platform.display()), 0);
    info_status(&format!("Zone ID: {}", config.cf_zone_id), 0);
    info_status(&format!("Record type: {}", config.dns_record_type), 0);
    info_status(&format!("Proxy enabled: {}", config.proxy), 0);
    info_status(&format!("TTL: {} seconds", config.ttl), 0);
    info_status(&format!("Host identifier: {}", config.platform_identifier), 0);
    if let Some(network) = &config.network {
        info_status(&format!("Network: {}", network), 0);
    }
    
    let domains = config.get_domain_names();
    info_status(&format!("Monitoring {} domain(s): {:?}", domains.len(), domains), 0);
    
    let client = CloudflareClient::new(cli_args.use_rustls);
    
    // æ‰§è¡Œä¸€æ¬¡æ›´æ–°
    info_step("Initial DDNS Update", 60, '=');
    if let Err(e) = run_ddns_update(&client, &config).await {
        error!("âŒ Initial update failed: {}", e);
    }
    
    // å¦‚æœæŒ‡å®šäº† --once å‚æ•°ï¼Œåªæ‰§è¡Œä¸€æ¬¡å°±é€€å‡º
    if cli_args.once {
        info_step("Completed (one-time mode)", 60, '=');
        return Ok(());
    }
    
    // æŒç»­è¿è¡Œæ¨¡å¼
    let interval = config.update_interval.unwrap_or(300);
    info_step(&format!("Starting update loop ({}s interval)", interval), 60, '=');
    
    loop {
        sleep(Duration::from_secs(interval)).await;
        
        info_step("Scheduled Update", 60, '-');
        if let Err(e) = run_ddns_update(&client, &config).await {
            error!("âŒ Scheduled update failed: {}", e);
        }
    }
}
```

## 3. åˆ›å»ºè·¨å¹³å°ç¼–è¯‘è„šæœ¬

### build-cross-platform.sh
```bash
#!/bin/bash
# Cross-platform build script for Cloudflare DDNS

set -e

BIN_NAME="cloudflare-ddns"
TARGETS=(
    "x86_64-unknown-linux-gnu"
    "x86_64-unknown-linux-musl"
    "aarch64-unknown-linux-gnu" 
    "aarch64-unknown-linux-musl"
    "x86_64-pc-windows-msvc"
    "x86_64-apple-darwin"
    "aarch64-apple-darwin"
)

# å®‰è£… cross (å¦‚æœå°šæœªå®‰è£…)
if ! command -v cross &> /dev/null; then
    echo "Installing cross..."
    cargo install cross --git https://github.com/cross-rs/cross
fi

# åˆ›å»ºè¾“å‡ºç›®å½•
mkdir -p dist

# ä¸ºæ¯ä¸ªç›®æ ‡å¹³å°ç¼–è¯‘
for target in "${TARGETS[@]}"; do
    echo "Building for $target..."
    
    # ä½¿ç”¨ cross ç¼–è¯‘
    cross build --release --target $target
    
    # ç¡®å®šäºŒè¿›åˆ¶æ–‡ä»¶æ‰©å±•å
    if [[ $target == *"windows"* ]]; then
        EXT="exe"
    else
        EXT=""
    fi
    
    # å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
    BIN_PATH="target/$target/release/$BIN_NAME"
    if [[ -n "$EXT" ]]; then
        BIN_PATH="$BIN_PATH.$EXT"
    fi
    
    if [[ -f "$BIN_PATH" ]]; then
        OUTPUT_NAME="${BIN_NAME}-${target}"
        if [[ -n "$EXT" ]]; then
            OUTPUT_NAME="$OUTPUT_NAME.$EXT"
        fi
        cp "$BIN_PATH" "dist/$OUTPUT_NAME"
        echo "âœ… Built: dist/$OUTPUT_NAME"
        
        # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
        file "dist/$OUTPUT_NAME"
        du -h "dist/$OUTPUT_NAME"
    else
        echo "âŒ Build failed for $target"
    fi
done

echo ""
echo "ğŸ‰ Build completed! All binaries are in the dist/ directory"
```

### build-windows.ps1 (Windows PowerShell è„šæœ¬)
```powershell
# Windows build script
$BinName = "cloudflare-ddns"
$Targets = @(
    "x86_64-pc-windows-msvc",
    "x86_64-pc-windows-gnu"
)

# Create dist directory
New-Item -ItemType Directory -Force -Path "dist" | Out-Null

foreach ($target in $Targets) {
    Write-Host "Building for $target..." -ForegroundColor Green
    
    # Build for target
    cargo build --release --target $target
    
    # Copy binary
    $BinPath = "target\$target\release\$BinName.exe"
    if (Test-Path $BinPath) {
        $OutputName = "$BinName-$target.exe"
        Copy-Item $BinPath "dist\$OutputName"
        Write-Host "âœ… Built: dist\$OutputName" -ForegroundColor Green
        
        # Show file info
        Get-ChildItem "dist\$OutputName" | Format-Table Name, Length, LastWriteTime
    } else {
        Write-Host "âŒ Build failed for $target" -ForegroundColor Red
    }
}

Write-Host "`nğŸ‰ Build completed! All binaries are in the dist directory" -ForegroundColor Cyan
```

## 4. åˆ›å»º README.md åŒ…å«ç¼–è¯‘è¯´æ˜

```markdown
# Cloudflare DDNS Client

A cross-platform dynamic DNS updater for Cloudflare written in Rust.

## Supported Platforms

- âœ… **Linux**: x86_64, AArch64 (glibc and musl)
- âœ… **Windows**: x86_64 (MSVC and GNU)
- âœ… **macOS**: x86_64, AArch64 (Apple Silicon)

## Quick Start

### Using Pre-built Binaries

Download the binary for your platform from the [Releases](https://github.com/yourusername/cloudflare-ddns/releases) page.

### From Source

#### Prerequisites

- Rust 1.70+ (install from [rustup.rs](https://rustup.rs/))
- For cross-compilation: Docker (for `cross` tool)

#### Basic Build

```bash
# Clone the repository
git clone https://github.com/yourusername/cloudflare-ddns.git
cd cloudflare-ddns

# Build for current platform
cargo build --release

# The binary will be at: target/release/cloudflare-ddns
```

#### Cross-compilation

**Using cross (recommended):**

```bash
# Install cross
cargo install cross --git https://github.com/cross-rs/cross

# Build for all supported platforms
chmod +x build-cross-platform.sh
./build-cross-platform.sh
```

**Manual cross-compilation:**

```bash
# Linux (musl - static linking)
rustup target add x86_64-unknown-linux-musl
cargo build --release --target x86_64-unknown-linux-musl

# Windows
rustup target add x86_64-pc-windows-msvc
cargo build --release --target x86_64-pc-windows-msvc

# macOS (from Linux)
rustup target add x86_64-apple-darwin
cargo build --release --target x86_64-apple-darwin
```

#### Platform-specific Notes

**Linux:**
- Use musl targets for maximum compatibility (static linking)
- glibc targets are smaller but require glibc on target system

**Windows:**
- MSVC target: Better performance, requires VC++ redistributable
- GNU target: No external dependencies, larger binary

**macOS:**
- Universal binaries not provided, choose appropriate architecture
- AArch64 for Apple Silicon, x86_64 for Intel Macs

## Binary Sizes

Typical binary sizes (release build):
- Linux (musl): ~4-5MB
- Linux (glibc): ~3-4MB  
- Windows: ~4-5MB
- macOS: ~4-5MB

## Features

- `native-tls` (default): Uses platform-native TLS (OpenSSL on Linux, Secure Transport on macOS, Schannel on Windows)
- `rustls`: Uses Rust TLS implementation (smaller binaries, no external dependencies)

Build with RustLS:
```bash
cargo build --release --no-default-features --features rustls
```

## Usage

See the main documentation for usage instructions.

## License

MIT OR Apache-2.0
```

## 5. åˆ›å»º .cargo/config.toml ç”¨äºç¼–è¯‘é…ç½®

```toml
[build]
# é»˜è®¤ç›®æ ‡ï¼ˆå¯é€‰ï¼‰
# target = "x86_64-unknown-linux-musl"

[target.x86_64-unknown-linux-musl]
linker = "x86_64-linux-musl-gcc"

[target.aarch64-unknown-linux-musl]
linker = "aarch64-linux-musl-gcc"

# ä¼˜åŒ–è®¾ç½®
[profile.release]
lto = true
codegen-units = 1
panic = "abort"  # å‡å°äºŒè¿›åˆ¶å¤§å°ï¼Œä½†å¤±å»æ ˆå›æº¯

# å¼€å‘é…ç½®
[profile.dev]
panic = "unwind"  # å¼€å‘æ—¶ä¿ç•™æ ˆå›æº¯
```

## 6. ä½¿ç”¨è¯´æ˜

### åŸºæœ¬ç¼–è¯‘ï¼š
```bash
# å½“å‰å¹³å°
cargo build --release

# ç‰¹å®šå¹³å°
cargo build --release --target x86_64-unknown-linux-musl

# ä½¿ç”¨ RustLSï¼ˆæ›´å°çš„äºŒè¿›åˆ¶ï¼‰
cargo build --release --no-default-features --features rustls
```

### æ˜¾ç¤ºå¹³å°ä¿¡æ¯ï¼š
```bash
./cloudflare-ddns --show-platform
```

### è·¨å¹³å°ç¼–è¯‘ï¼š
```bash
# ä½¿ç”¨è„šæœ¬ï¼ˆéœ€è¦ Dockerï¼‰
./build-cross-platform.sh

# æˆ–æ‰‹åŠ¨å®‰è£…ç›®æ ‡
rustup target add x86_64-unknown-linux-musl
cargo build --release --target x86_64-unknown-linux-musl
```

è¿™ä¸ªé…ç½®æä¾›äº†å®Œæ•´çš„è·¨å¹³å°æ”¯æŒï¼ŒåŒ…æ‹¬ï¼š
- å¹³å°æ£€æµ‹å’Œç‰¹å®šåŠŸèƒ½
- å¤šç§ç¼–è¯‘ç›®æ ‡
- ä¼˜åŒ–é…ç½®
- è¯¦ç»†çš„ç¼–è¯‘æ–‡æ¡£
- è‡ªåŠ¨åŒ–æ„å»ºè„šæœ¬